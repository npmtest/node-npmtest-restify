{"/home/travis/build/npmtest/node-npmtest-restify/test.js":"/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/lib.npmtest_restify.js":"/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_restify = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_restify = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-restify && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_restify\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_restify.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_restify.rollup.js'] =\n            local.assetsDict['/assets.npmtest_restify.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_restify.__dirname + '/lib.npmtest_restify.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n//\n// Restify supports both a client and server API, and in the essence of not\n// loading the kitchen sink on clients, the exports here is chunked up into\n// client and server; note clients will have to opt in by setting the env\n// var \"RESTIFY_CLIENT_ONLY\", but if you're in that boat, it's not hard to do,\n// and enables much faster load times\n//\n\n'use strict';\n\nvar shallowCopy = require('./utils').shallowCopy;\n\n\n/**\n * creates an http request client. based on options passed in, will create one\n * of three existing clients: Http, String, or Json.\n * @public\n * @function createClient\n * @param    {Object} options      an options object\n * @param    {String} options.type 'http' | 'json' | 'string'\n * @returns  {HttpClient | JsonClient | StringClient}\n */\nfunction createClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    var assert = require('assert-plus');\n    var bunyan = require('./bunyan_helper');\n    var clients = require('./clients');\n\n    assert.object(options, 'options');\n\n    var client;\n    var opts = shallowCopy(options);\n    opts.agent = options.agent;\n    opts.name = opts.name || 'restify';\n    opts.type = opts.type || 'application/octet-stream';\n    opts.log = opts.log || bunyan.createLogger(opts.name);\n\n    switch (opts.type) {\n        case 'json':\n            client = new clients.JsonClient(opts);\n            break;\n\n        case 'string':\n            client = new clients.StringClient(opts);\n            break;\n\n        case 'http':\n        default:\n            client = new clients.HttpClient(opts);\n            break;\n    }\n\n    return (client);\n}\n\n\n/**\n * creates a json httpclient.\n * @public\n * @function createJsonClient\n * @param    {Object}     options an options object\n * @returns  {JsonClient}         a json client\n */\nfunction createJsonClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'json';\n    return (createClient(options));\n}\n\n\n/**\n * creates a string httpclient.\n * @public\n * @function createStringClient\n * @param    {Object}       options an options object\n * @returns  {StringClient}         a string client\n */\nfunction createStringClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'string';\n    return (createClient(options));\n}\n\n\n/**\n * creates a regular httpclient.\n * @public\n * @function createHttpClient\n * @param    {Object}     options an options object\n * @returns  {HttpClient}         an http client\n */\nfunction createHttpClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'http';\n    return (createClient(options));\n}\n\n\n/**\n * creates a server.\n * @public\n * @function createServer\n * @param    {Object} options an options object\n * @returns  {Server}\n */\nfunction createServer(options) {\n    var bunyan = require('./bunyan_helper');\n    var InternalError = require('./errors').InternalError;\n    var Router = require('./router');\n    var Server = require('./server');\n\n    var opts = shallowCopy(options || {});\n    var server;\n\n    opts.name = opts.name || 'restify';\n    opts.log = opts.log || bunyan.createLogger(opts.name);\n    opts.router = opts.router || new Router(opts);\n\n    server = new Server(opts);\n\n    if (server.handleUncaughtExceptions) {\n        server.on('uncaughtException', function (req, res, route, e) {\n            if (this.listeners('uncaughtException').length > 1 ||\n                res.headersSent) {\n                return (false);\n            }\n\n            res.send(new InternalError(e, e.message || 'unexpected error'));\n            return (true);\n        });\n    }\n\n    return (server);\n}\n\n\n/**\n * Returns a string representation of a URL pattern , with its\n * parameters filled in by the passed hash.\n *\n * If a key is not found in the hash for a param, it is left alone.\n * @public\n * @function realizeUrl\n * @param   {String} pattern a url string\n * @param   {Object} params  a hash of parameter names to values for\n *                           substitution\n * @returns {String}\n */\nfunction realizeUrl(pattern, params) {\n    var p = pattern.replace(/\\/:([^/]+)/g, function (match, k) {\n        return (params.hasOwnProperty(k) ? '/' + params[k] : match);\n    });\n\n\n    return (require('./utils').sanitizePath(p));\n}\n\n\n///--- Exports\n\nmodule.exports = {\n    // Client API\n    createClient: createClient,\n    createJsonClient: createJsonClient,\n    createJSONClient: createJsonClient,\n    createStringClient: createStringClient,\n    createHttpClient: createHttpClient,\n    get HttpClient() {\n        return (require('./clients').HttpClient);\n    },\n    get JsonClient() {\n        return (require('./clients').JsonClient);\n    },\n    get StringClient() {\n        return (require('./clients').StringClient);\n    },\n\n    // Miscellaneous API\n    get bunyan() {\n        return (require('./bunyan_helper'));\n    },\n\n    errors: {}\n\n};\n\nvar errors = require('./errors');\nObject.keys(errors).forEach(function (k) {\n    module.exports.errors[k] = errors[k];\n    module.exports[k] = errors[k];\n});\n\nif (!process.env.RESTIFY_CLIENT_ONLY) {\n\n    module.exports.createServer = createServer;\n    module.exports.httpDate = require('./http_date');\n    module.exports.realizeUrl = realizeUrl;\n    module.exports.formatters = require('./formatters');\n    module.exports.plugins = {};\n    var plugins = require('./plugins');\n    Object.keys(plugins).forEach(function (k) {\n        module.exports.plugins[k] = plugins[k];\n        module.exports[k] = plugins[k];\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/utils.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n/**\n * Cleans up sloppy URL paths, like /foo////bar/// to /foo/bar.\n * @public\n * @method  sanitizePath\n * @param   {String} path the HTTP resource path.\n * @returns {String}      Cleaned up form of path.\n */\nfunction sanitizePath(path) {\n    assert.ok(path);\n\n    // Be nice like apache and strip out any //my//foo//bar///blah\n    path = path.replace(/\\/\\/+/g, '/');\n\n    // Kill a trailing '/'\n    if (path.lastIndexOf('/') === (path.length - 1) && path.length > 1) {\n        path = path.substr(0, path.length - 1);\n    }\n\n    return (path);\n}\n\n\n/**\n * Return a shallow copy of the given object;\n * @public\n * @method  shallowCopy\n * @param   {Object} obj the object to copy\n * @returns {Object}     the new copy of the object\n */\nfunction shallowCopy(obj) {\n    if (!obj) {\n        return (obj);\n    }\n    var copy = {};\n    Object.keys(obj).forEach(function (k) {\n        copy[k] = obj[k];\n    });\n    return (copy);\n}\n\n\n/**\n * Merges two query parameter objects. Merges to array\n * if the same key is encountered.\n * @public\n * @method  mergeQs\n * @param   {Object} obj1 first qs object\n * @param   {Object} obj2 second qs object\n * @returns {Object}      the merged object\n */\nfunction mergeQs(obj1, obj2) {\n\n    var merged = shallowCopy(obj1) || {};\n\n    // defend against null cause null is an object. yay js.\n    if (obj2 && typeof (obj2) === 'object') {\n        Object.keys(obj2).forEach(function (key) {\n            // if we already have this key and it isn't an array,\n            // make it one array of the same element.\n            if (merged.hasOwnProperty(key) && !(merged[key] instanceof Array)) {\n                merged[key] = [merged[key]];\n\n                // push the new value down\n                merged[key].push(obj2[key]);\n            } else {\n                // otherwise just set it\n                merged[key] = obj2[key];\n            }\n        });\n    }\n\n    return (merged);\n}\n\n\n///--- Exports\n\nmodule.exports = {\n    sanitizePath: sanitizePath,\n    shallowCopy: shallowCopy,\n    mergeQs: mergeQs\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/errors/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar httpErrors = require('./http_error');\nvar restErrors = require('./rest_error');\n\n\nmodule.exports = {};\n\nObject.keys(httpErrors).forEach(function (k) {\n    module.exports[k] = httpErrors[k];\n});\n\n// Note some of the RestErrors overwrite plain HTTP errors.\nObject.keys(restErrors).forEach(function (k) {\n    module.exports[k] = restErrors[k];\n});\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/errors/http_error.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n// Because we are constructing error objects dynamically, we use an anonymous\n// function as the 'base constructor' then use arguments.callee to fill that in.\n// strict mode disallows agruments.callee, disable both of these rules.\n\n/* eslint-disable strict, no-caller */\n\nvar http = require('http');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar WError = require('verror').WError;\n\n\n///--- Globals\n\nvar slice = Function.prototype.call.bind(Array.prototype.slice);\n\n\n///--- Helpers\n\n/**\n * used to programatically create http error code names, using the underlying\n * status codes names exposed via the http module.\n * @private\n * @function codeToErrorName\n * @param    {Number} code the http error code to dynamically create\n * @returns  {String}\n */\nfunction codeToErrorName(code) {\n    code = parseInt(code, 10);\n    var status = http.STATUS_CODES[code];\n\n    if (!status) {\n        return (false);\n    }\n\n\n    var pieces = status.split(/\\s+/);\n    var str = '';\n    pieces.forEach(function (s) {\n        str += s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();\n    });\n\n    str = str.replace(/\\W+/g, '');\n\n    if (!/\\w+Error$/.test(str)) {\n        str += 'Error';\n    }\n\n    return (str);\n}\n\n\n///--- Error Base class\n\n/**\n * HttpError class. inherits from WError.\n * @public\n * @class\n * @param {Object} options an options object\n */\nfunction HttpError(options) {\n    assert.object(options, 'options');\n\n    options.constructorOpt = options.constructorOpt || HttpError;\n    WError.apply(this, arguments);\n\n    var self = this;\n    var code = parseInt((options.statusCode || 500), 10);\n    this.statusCode = code;\n    this.body = options.body || {\n        code: codeToErrorName(code),\n        message: options.message || self.message\n    };\n    this.message = options.message || self.message;\n}\nutil.inherits(HttpError, WError);\n\n\n///--- Exports\n\nmodule.exports = {\n\n    HttpError: HttpError,\n\n    codeToHttpError: function codeToHttpError(code, message, body) {\n        var err;\n        var name = codeToErrorName(code);\n\n        if (!name) {\n            err = new HttpError({\n                statusCode: code,\n                message: message,\n                body: body\n            });\n            err.name = 'Http' + code + 'Error';\n        } else {\n            err = new module.exports[name]({\n                body: body,\n                message: message,\n                constructorOpt: codeToHttpError,\n                statusCode: code\n            });\n        }\n\n        return (err);\n    }\n\n};\n\n\n// Export all the 4xx and 5xx HTTP Status codes as Errors\nvar codes = Object.keys(http.STATUS_CODES);\n\ncodes.forEach(function (code) {\n    if (code < 400) {\n        return;\n    }\n\n    var name = codeToErrorName(code);\n\n    module.exports[name] = function (cause, message) {\n        var index = 1;\n        var opts = {\n            statusCode: code\n        };\n\n        if (cause && cause instanceof Error) {\n            opts.cause = cause;\n            opts.constructorOpt = arguments.callee;\n        } else if (typeof (cause) === 'object') {\n            opts.body = cause.body;\n            opts.cause = cause.cause;\n            opts.constructorOpt = cause.constructorOpt;\n            opts.message = cause.message;\n            opts.statusCode = cause.statusCode || code;\n        } else {\n            opts.constructorOpt = arguments.callee;\n            index = 0;\n        }\n\n        var args = slice(arguments, index);\n        args.unshift(opts);\n        HttpError.apply(this, args);\n    };\n    util.inherits(module.exports[name], HttpError);\n\n    module.exports[name].displayName =\n        module.exports[name].prototype.name =\n            name;\n});\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/errors/rest_error.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n// Because we are constructing error objects dynamically, we use an anonymous\n// function as the 'base constructor' then use arguments.callee to fill that in.\n// strict mode disallows agruments.callee, disable both of these rules.\n\n/* eslint-disable strict, no-caller */\n\nvar util = require('util');\n\nvar assert = require('assert-plus');\n\nvar httpErrors = require('./http_error');\n\n\n///--- Globals\n\nvar slice = Function.prototype.call.bind(Array.prototype.slice);\n\nvar HttpError = httpErrors.HttpError;\n\nvar CODES = {\n    BadDigest: 400,\n    BadMethod: 405,\n    Internal: 500, // Don't have InternalErrorError\n    InvalidArgument: 409,\n    InvalidContent: 400,\n    InvalidCredentials: 401,\n    InvalidHeader: 400,\n    InvalidVersion: 400,\n    MissingParameter: 409,\n    NotAuthorized: 403,\n    PreconditionFailed: 412,\n    RequestExpired: 400,\n    RequestThrottled: 429,\n    ResourceNotFound: 404,\n    WrongAccept: 406\n};\n\n\n///--- API\n\nfunction RestError(options) {\n    assert.object(options, 'options');\n\n    options.constructorOpt = options.constructorOpt || RestError;\n    HttpError.apply(this, arguments);\n\n    var self = this;\n    this.restCode = options.restCode || 'Error';\n    this.body = options.body || {\n        code: self.restCode,\n        message: options.message || self.message\n    };\n}\nutil.inherits(RestError, HttpError);\n\n\n///--- Exports\n\nmodule.exports = {\n    RestError: RestError\n};\n\nObject.keys(CODES).forEach(function (k) {\n    var name = k;\n\n    if (!/\\w+Error$/.test(name)) {\n        name += 'Error';\n    }\n\n    module.exports[name] = function (cause, message) {\n        var index = 1;\n        var opts = {\n            restCode: (k === 'Internal' ? 'InternalError' : k),\n            statusCode: CODES[k]\n        };\n\n        opts.constructorOpt = arguments.callee;\n\n        if (cause && cause instanceof Error) {\n            opts.cause = cause;\n        } else if (typeof (cause) === 'object') {\n            opts.body = cause.body;\n            opts.cause = cause.cause;\n            opts.message = cause.message;\n            opts.statusCode = cause.statusCode || CODES[k];\n        } else {\n            index = 0;\n        }\n\n        var args = slice(arguments, index);\n        args.unshift(opts);\n        RestError.apply(this, args);\n    };\n    util.inherits(module.exports[name], RestError);\n    module.exports[name].displayName =\n        module.exports[name].prototype.name =\n            name;\n});\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/http_date.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n/**\n * takes an instance of a date object, formats it UTC\n *     e.g., Wed, 17 Jun 2015 01:30:26 GMT\n * @public\n * @function httpDate\n * @param    {Object} now a date object\n * @returns  {String}     formatted dated object\n */\nmodule.exports = function httpDate(now) {\n    if (!now) {\n        now = new Date();\n    }\n\n    return (now.toUTCString());\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/formatters/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\nmodule.exports = {\n    'application/javascript; q=0.1': require('./jsonp'),\n    'application/json; q=0.4': require('./json'),\n    'text/plain; q=0.3': require('./text'),\n    'application/octet-stream; q=0.2': require('./binary')\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/formatters/jsonp.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSONP formatter. like JSON, but with a callback invocation.\n * @public\n * @function formatJSONP\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatJSONP(req, res, body, cb) {\n    if (!body) {\n        res.setHeader('Content-Length', 0);\n        return (null);\n    }\n\n    if (body instanceof Error) {\n        if ((body.restCode || body.httpCode) && body.body) {\n            body = body.body;\n        } else {\n            body = {\n                message: body.message\n            };\n        }\n    }\n\n    if (Buffer.isBuffer(body)) {\n        body = body.toString('base64');\n    }\n\n    var _cb = req.query.callback || req.query.jsonp;\n    var data;\n\n    if (_cb) {\n        data = 'typeof ' + _cb + ' === \\'function\\' && ' +\n                _cb + '(' + JSON.stringify(body) + ');';\n    } else {\n        data = JSON.stringify(body);\n    }\n\n    res.setHeader('Content-Length', Buffer.byteLength(data));\n    return cb(null, data);\n}\n\nmodule.exports = formatJSONP;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/formatters/json.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSON formatter.\n * @public\n * @function formatJSON\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatJSON(req, res, body, cb) {\n    if (body instanceof Error) {\n        // snoop for RestError or HttpError, but don't rely on\n        // instanceof\n        res.statusCode = body.statusCode || 500;\n\n        if (body.body) {\n            body = body.body;\n        } else {\n            body = {\n                message: body.message\n            };\n        }\n    } else if (Buffer.isBuffer(body)) {\n        body = body.toString('base64');\n    }\n\n    var data = JSON.stringify(body);\n    res.setHeader('Content-Length', Buffer.byteLength(data));\n\n    return cb(null, data);\n}\n\nmodule.exports = formatJSON;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/formatters/text.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSONP formatter. like JSON, but with a callback invocation.\n * @public\n * @function formatJSONP\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatText(req, res, body, cb) {\n    if (body instanceof Error) {\n        res.statusCode = body.statusCode || 500;\n        body = body.message;\n    } else if (typeof (body) === 'object') {\n        body = JSON.stringify(body);\n    } else {\n        body = body.toString();\n    }\n\n    res.setHeader('Content-Length', Buffer.byteLength(body));\n    return cb(null, body);\n}\n\nmodule.exports = formatText;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/formatters/binary.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * binary formatter.\n * @public\n * @function formatBinary\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {Buffer}\n */\nfunction formatBinary(req, res, body, cb) {\n    if (body instanceof Error) {\n        res.statusCode = body.statusCode || 500;\n    }\n\n    if (!Buffer.isBuffer(body)) {\n        body = new Buffer(body.toString());\n    }\n\n    res.setHeader('Content-Length', body.length);\n    return cb(null, body);\n}\n\nmodule.exports = formatBinary;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\nmodule.exports = {\n    acceptParser: require('./accept'),\n    auditLogger: require('./audit'),\n    authorizationParser: require('./authorization'),\n    bodyParser: require('./body_parser'),\n    conditionalRequest: require('./conditional_request'),\n    CORS: require('./cors'),\n    dateParser: require('./date'),\n    jsonp: require('./jsonp'),\n    urlEncodedBodyParser: require('./form_body_parser'),\n    requestLogger: require('./bunyan'),\n    gzipResponse: require('./gzip'),\n    fullResponse: require('./full_response'),\n    jsonBodyParser: require('./json_body_parser'),\n    multipartBodyParser: require('./multipart_body_parser'),\n    queryParser: require('./query'),\n    requestExpiry: require('./request_expiry'),\n    sanitizePath: require('./pre/pre_path'),\n    serveStatic: require('./static'),\n    throttle: require('./throttle'),\n\n    pre: {\n        pause: require('./pre/pause'),\n        sanitizePath: require('./pre/pre_path'),\n        userAgentConnection: require('./pre/user_agent')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/accept.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\n\nvar NotAcceptableError = require('../errors').NotAcceptableError;\n\n\n/**\n * Returns a plugin that will check the client's Accept header can be handled\n * by this server.\n *\n * Note you can get the set of types allowed from a restify server by doing\n * `server.acceptable`.\n *\n * @public\n * @function acceptParser\n * @throws   {NotAcceptableError}\n * @param    {String}    acceptable array of accept types.\n * @returns  {Function}             restify handler.\n */\nfunction acceptParser(acceptable) {\n    if (!Array.isArray(acceptable)) {\n        acceptable = [acceptable];\n    }\n    assert.arrayOfString(acceptable, 'acceptable');\n\n    acceptable = acceptable.filter(function (a) {\n        return (a);\n    }).map(function (a) {\n            return ((a.indexOf('/') === -1) ? mime.lookup(a) : a);\n        }).filter(function (a) {\n            return (a);\n        });\n\n    var e = new NotAcceptableError('Server accepts: ' + acceptable.join());\n\n    function parseAccept(req, res, next) {\n        if (req.accepts(acceptable)) {\n            next();\n            return;\n        }\n\n        res.json(e);\n        next(false);\n    }\n\n    return (parseAccept);\n}\n\nmodule.exports = acceptParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/audit.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar bunyan = require('bunyan');\n\nvar HttpError = require('../errors').HttpError;\n\n\n///--- API\n\n/**\n * Returns a Bunyan audit logger suitable to be used in a server.on('after')\n * event.  I.e.:\n *\n * server.on('after', restify.auditLogger({ log: myAuditStream }));\n *\n * This logs at the INFO level.\n *\n * @public\n * @function auditLogger\n * @param   {Object}   options at least a bunyan logger (log).\n * @returns {Function}         to be used in server.after.\n */\nfunction auditLogger(options) {\n    assert.object(options, 'options');\n    assert.object(options.log, 'options.log');\n    var errSerializer = bunyan.stdSerializers.err;\n\n    if (options.log.serializers && options.log.serializers.err) {\n        errSerializer = options.log.serializers.err;\n    }\n\n    var log = options.log.child({\n        audit: true,\n        serializers: {\n            err: errSerializer,\n            req: function auditRequestSerializer(req) {\n                if (!req) {\n                    return (false);\n                }\n\n                var timers = {};\n                (req.timers || []).forEach(function (time) {\n                    var t = time.time;\n                    var _t = Math.floor((1000000 * t[0]) +\n                        (t[1] / 1000));\n                    timers[time.name] = _t;\n                });\n                return ({\n                    // account for native and queryParser plugin usage\n                    query: (typeof req.query === 'function') ?\n                            req.query() : req.query,\n                    method: req.method,\n                    url: req.url,\n                    headers: req.headers,\n                    httpVersion: req.httpVersion,\n                    trailers: req.trailers,\n                    version: req.version(),\n                    body: options.body === true ?\n                        req.body : undefined,\n                    timers: timers\n                });\n            },\n            res: function auditResponseSerializer(res) {\n                if (!res) {\n                    return (false);\n                }\n\n\n                var body;\n\n                if (options.body === true) {\n                    if (res._body instanceof HttpError) {\n                        body = res._body.body;\n                    } else {\n                        body = res._body;\n                    }\n                }\n\n                return ({\n                    statusCode: res.statusCode,\n                    headers: res._headers,\n                    trailer: res._trailer || false,\n                    body: body\n                });\n            }\n        }\n    });\n\n    function audit(req, res, route, err) {\n        var latency = res.get('Response-Time');\n\n        if (typeof (latency) !== 'number') {\n            latency = Date.now() - req._time;\n        }\n\n        var obj = {\n            remoteAddress: req.connection.remoteAddress,\n            remotePort: req.connection.remotePort,\n            req_id: req.getId(),\n            req: req,\n            res: res,\n            err: err,\n            latency: latency,\n            secure: req.secure,\n            _audit: true\n        };\n\n        log.info(obj, 'handled: %d', res.statusCode);\n\n        return (true);\n    }\n\n    return (audit);\n}\n\n\n///-- Exports\n\nmodule.exports = auditLogger;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/authorization.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar httpSignature = require('http-signature');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar InvalidHeaderError = errors.InvalidHeaderError;\n\nvar OPTIONS = {\n    algorithms: [\n        'rsa-sha1',\n        'rsa-sha256',\n        'rsa-sha512',\n        'dsa-sha1',\n        'hmac-sha1',\n        'hmac-sha256',\n        'hmac-sha512'\n    ]\n};\n\n\n///--- Helpers\n\nfunction parseBasic(string) {\n    var decoded;\n    var index;\n    var pieces;\n\n    decoded = (new Buffer(string, 'base64')).toString('utf8');\n\n    if (!decoded) {\n        throw new InvalidHeaderError('Authorization header invalid');\n    }\n\n    index = decoded.indexOf(':');\n\n    if (index === -1) {\n        pieces = [decoded];\n    } else {\n        pieces = [decoded.slice(0, index), decoded.slice(index + 1)];\n    }\n\n    if (!pieces || typeof (pieces[0]) !== 'string') {\n        throw new InvalidHeaderError('Authorization header invalid');\n    }\n\n    // Allows for usernameless authentication\n    if (!pieces[0]) {\n        pieces[0] = null;\n    }\n\n    // Allows for passwordless authentication\n    if (!pieces[1]) {\n        pieces[1] = null;\n    }\n\n    return ({\n        username: pieces[0],\n        password: pieces[1]\n    });\n}\n\n\nfunction parseSignature(request, options) {\n    options = options || {};\n    options.algorithms = OPTIONS.algorithms;\n\n    try {\n        return (httpSignature.parseRequest(request, options));\n    } catch (e) {\n        throw new InvalidHeaderError('Authorization header invalid: ' +\n            e.message);\n    }\n}\n\n\n/**\n * Returns a plugin that will parse the client's Authorization header.\n *\n * Subsequent handlers will see `req.authorization`, which looks like:\n *\n * {\n *   scheme: <Basic|Signature|...>,\n *   credentials: <Undecoded value of header>,\n *   basic: {\n *     username: $user\n *     password: $password\n *   }\n * }\n *\n * `req.username` will also be set, and defaults to 'anonymous'.\n *\n * @public\n * @function authorizationParser\n * @throws   {InvalidArgumentError}\n * @param    {Object} options an options object\n * @returns  {Function}\n */\nfunction authorizationParser(options) {\n\n    function parseAuthorization(req, res, next) {\n        req.authorization = {};\n        req.username = 'anonymous';\n\n        if (!req.headers.authorization) {\n            return (next());\n        }\n\n        var pieces = req.headers.authorization.split(' ', 2);\n\n        if (!pieces || pieces.length !== 2) {\n            var e = new InvalidHeaderError('BasicAuth content ' +\n                'is invalid.');\n            return (next(e));\n        }\n\n        req.authorization.scheme = pieces[0];\n        req.authorization.credentials = pieces[1];\n\n        try {\n            switch (pieces[0].toLowerCase()) {\n                case 'basic':\n                    req.authorization.basic = parseBasic(pieces[1]);\n                    req.username = req.authorization.basic.username;\n                    break;\n\n                case 'signature':\n                    req.authorization.signature =\n                        parseSignature(req, options);\n                    req.username =\n                        req.authorization.signature.keyId;\n                    break;\n\n                default:\n                    break;\n            }\n        } catch (e2) {\n            return (next(e2));\n        }\n\n        return (next());\n    }\n\n    return (parseAuthorization);\n}\n\nmodule.exports = authorizationParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\nvar bodyReader = require('./body_reader');\nvar jsonParser = require('./json_body_parser');\nvar formParser = require('./form_body_parser');\nvar multipartParser = require('./multipart_body_parser');\nvar fieldedTextParser = require('./fielded_text_body_parser.js');\n\n\n///--- Globals\n\nvar UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;\n\n\n///--- API\n\n/**\n * parse the body of an incoming request.\n * @public\n * @function bodyParser\n * @throws   {UnsupportedMediaTypeError}\n * @param    {Object} options an option object\n * @returns  {Array}\n */\nfunction bodyParser(options) {\n    assert.optionalObject(options, 'options');\n    options = options || {};\n    options.bodyReader = true;\n\n    var read = bodyReader(options);\n    var parseForm = formParser(options);\n    var parseJson = jsonParser(options);\n    var parseMultipart = multipartParser(options);\n    var parseFieldedText = fieldedTextParser(options);\n\n    function parseBody(req, res, next) {\n        // Allow use of 'requestBodyOnGet' flag to allow for merging of\n        // the request body of a GET request into req.params\n        if (req.method === 'HEAD') {\n            next();\n            return;\n        }\n\n        if (req.method === 'GET') {\n            if (!options.requestBodyOnGet) {\n                next();\n                return;\n            }\n        }\n\n        if (req.contentLength() === 0 && !req.isChunked()) {\n            next();\n            return;\n        }\n\n        var parser;\n        var type = req.contentType().toLowerCase();\n\n        switch (type) {\n            case 'application/json':\n                parser = parseJson[0];\n                break;\n            case 'application/x-www-form-urlencoded':\n                parser = parseForm[0];\n                break;\n            case 'multipart/form-data':\n                parser = parseMultipart;\n                break;\n            case 'text/tsv':\n                parser = parseFieldedText;\n                break;\n            case 'text/tab-separated-values':\n                parser = parseFieldedText;\n                break;\n            case 'text/csv':\n                parser = parseFieldedText;\n                break;\n\n            default:\n                break;\n        }\n\n        if (parser) {\n            parser(req, res, next);\n        } else if (options && options.rejectUnknown) {\n            next(new UnsupportedMediaTypeError(type));\n        } else {\n            next();\n        }\n    }\n\n    return ([read, parseBody]);\n}\n\nmodule.exports = bodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/body_reader.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar BadDigestError = errors.BadDigestError;\nvar RequestEntityTooLargeError = errors.RequestEntityTooLargeError;\nvar PayloadTooLargeError = errors.PayloadTooLargeError;\n\nvar MD5_MSG = 'Content-MD5 \\'%s\\' didn\\'t match \\'%s\\'';\n\n\n///--- Helpers\n\nfunction createBodyWriter(req) {\n    var buffers = [];\n\n    var contentType = req.contentType();\n    var isText = false;\n\n    if (!contentType ||\n        contentType === 'application/json' ||\n        contentType === 'application/x-www-form-urlencoded' ||\n        contentType === 'multipart/form-data' ||\n        contentType.substr(0, 5) === 'text/') {\n        isText = true;\n    }\n\n    req.body = new Buffer(0);\n    return {\n        write: function (chunk) {\n            buffers.push(chunk);\n        },\n        end: function () {\n            req.body = Buffer.concat(buffers);\n\n            if (isText) {\n                req.body = req.body.toString('utf8');\n            }\n        }\n    };\n}\n\n\n///--- API\n\n/**\n * reads the body of the request.\n * @public\n * @function bodyReader\n * @throws   {BadDigestError | PayloadTooLargeError}\n * @param    {Object} options an options object\n * @returns  {Function}\n */\nfunction bodyReader(options) {\n    options = options || {};\n    assert.object(options, 'options');\n\n    var maxBodySize = options.maxBodySize || 0;\n\n    function readBody(req, res, next) {\n        if ((req.getContentLength() === 0 && !req.isChunked()) ||\n            req.contentType() === 'multipart/form-data' ||\n            req.contentType() === 'application/octet-stream') {\n            next();\n            return;\n        }\n        var bodyWriter = createBodyWriter(req);\n\n        var bytesReceived = 0;\n        var digest;\n        var gz;\n        var hash;\n        var md5;\n\n        if ((md5 = req.headers['content-md5'])) {\n            hash = crypto.createHash('md5');\n        }\n\n        function done() {\n            var errorMessage;\n            bodyWriter.end();\n\n            if (maxBodySize && bytesReceived > maxBodySize) {\n                var msg = 'Request body size exceeds ' +\n                    maxBodySize;\n\n                // Between Node 0.12 and 4 http status code messages changed\n                // RequestEntityTooLarge was changed to PayloadTooLarge\n                // this check is to maintain backwards compatibility\n                if (PayloadTooLargeError !== undefined) {\n                    errorMessage = new PayloadTooLargeError(msg);\n                } else {\n                    errorMessage = new RequestEntityTooLargeError(msg);\n                }\n\n                next(errorMessage);\n                return;\n            }\n\n            if (!req.body.length) {\n                next();\n                return;\n            }\n\n            if (hash && md5 !== (digest = hash.digest('base64'))) {\n                errorMessage = new BadDigestError(MD5_MSG, md5, digest);\n                next(errorMessage);\n                return;\n            }\n\n            next();\n        }\n\n        if (req.headers['content-encoding'] === 'gzip') {\n            gz = zlib.createGunzip();\n            gz.on('data', bodyWriter.write);\n            gz.once('end', done);\n            req.once('end', gz.end.bind(gz));\n        } else {\n            req.once('end', done);\n        }\n\n        req.on('data', function onRequestData(chunk) {\n            if (maxBodySize) {\n                bytesReceived += chunk.length;\n\n                if (bytesReceived > maxBodySize) {\n                    return;\n                }\n            }\n\n            if (hash) {\n                hash.update(chunk, 'binary');\n            }\n\n            if (gz) {\n                gz.write(chunk);\n            } else {\n                bodyWriter.write(chunk);\n            }\n        });\n\n        req.once('error', next);\n        req.resume();\n    }\n\n    return (readBody);\n}\n\nmodule.exports = bodyReader;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/json_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar bodyReader = require('./body_reader');\nvar errors = require('../errors');\n\n\n///--- API\n\n/**\n * parses json body from the request.\n * @public\n * @function jsonBodyParser\n * @param    {Object}               options an options object\n * @throws   {InvalidContentError}          on bad input\n * @returns  {Function}\n */\nfunction jsonBodyParser(options) {\n    assert.optionalObject(options, 'options');\n    options = options || {};\n\n    var override = options.overrideParams;\n\n    function parseJson(req, res, next) {\n        if (req.getContentType() !== 'application/json' || !req.body) {\n            next();\n            return;\n        }\n\n        var params;\n\n        try {\n            params = JSON.parse(req.body, options.reviver);\n        } catch (e) {\n            next(new errors.InvalidContentError('Invalid JSON: ' +\n                e.message));\n            return;\n        }\n\n        if (options.mapParams !== false) {\n            if (Array.isArray(params)) {\n                req.params = params;\n            } else if (typeof (params) === 'object' && params !== null) {\n                Object.keys(params).forEach(function (k) {\n                    var p = req.params[k];\n\n                    if (p && !override) {\n                        return (false);\n                    }\n                    req.params[k] = params[k];\n                    return (true);\n                });\n            } else {\n                req.params = params || req.params;\n            }\n        } else {\n            req._body = req.body;\n        }\n\n        req.body = params;\n\n        next();\n    }\n\n    var chain = [];\n\n    if (!options.bodyReader) {\n        chain.push(bodyReader(options));\n    }\n    chain.push(parseJson);\n    return (chain);\n}\n\nmodule.exports = jsonBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/form_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar querystring = require('qs');\n\nvar bodyReader = require('./body_reader');\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar MIME_TYPE = 'application/x-www-form-urlencoded';\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body IFF the\n * contentType is application/x-www-form-urlencoded.\n *\n * If req.params already contains a given key, that key is skipped and an\n * error is logged.\n *\n * @public\n * @function urlEncodedBodyParser\n * @param   {Object}    options an option sobject\n * @returns {Function}\n */\nfunction urlEncodedBodyParser(options) {\n    options = options || {};\n    assert.object(options, 'options');\n\n    var override = options.overrideParams;\n\n    function parseUrlEncodedBody(req, res, next) {\n        if (req.getContentType() !== MIME_TYPE || !req.body) {\n            next();\n            return;\n        }\n\n        try {\n            var params = querystring.parse(req.body);\n\n            if (options.mapParams !== false) {\n                var keys = Object.keys(params);\n                keys.forEach(function (k) {\n                    var p = req.params[k];\n\n                    if (p && !override) {\n                        return (false);\n                    }\n\n                    req.params[k] = params[k];\n                    return (true);\n                });\n            } else {\n                req._body = req.body;\n                req.body = params;\n            }\n        } catch (e) {\n            next(new errors.InvalidContentError(e.message));\n            return;\n        }\n\n        req.log.trace('req.params now: %j', req.params);\n        next();\n    }\n\n    var chain = [];\n\n    if (!options.bodyReader) {\n        chain.push(bodyReader(options));\n    }\n    chain.push(parseUrlEncodedBody);\n    return (chain);\n}\n\nmodule.exports = urlEncodedBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/multipart_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar fs = require('fs');\n\nvar assert = require('assert-plus');\nvar formidable = require('formidable');\nvar once = require('once');\nvar vasync = require('vasync');\n\nvar errors = require('../errors');\n\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body IFF the\n * contentType is multipart/form-data\n *\n * If req.params already contains a given key, that key is skipped and an\n * error is logged.\n * @public\n * @function multipartBodyParser\n * @param    {Object}          options an options object\n * @throws   {BadRequestError}\n * @returns  {Function}\n */\nfunction multipartBodyParser(options) {\n    if (!options) {\n        options = {};\n    }\n    assert.object(options, 'options');\n    assert.optionalBool(options.overrideParams, 'options.overrideParams');\n    assert.optionalBool(options.multiples, 'options.multiples');\n    assert.optionalBool(options.keepExtensions, 'options.keepExtensions');\n    assert.optionalString(options.uploadDir, 'options.uploadDir');\n    assert.optionalNumber(options.maxFieldsSize, 'options.maxFieldsSize');\n    assert.optionalString(options.hash, 'options.hash');\n    assert.optionalFunc(options.multipartFileHandler,\n                        'options.multipartFileHandler');\n    assert.optionalFunc(options.multipartHandler, 'options.multipartHandler');\n    assert.optionalBool(options.mapParams, 'options.mapParams');\n    assert.optionalBool(options.mapFiles, 'options.mapFiles');\n\n    var override = options.overrideParams;\n\n    function parseMultipartBody(req, res, next) {\n        next = once(next);\n\n        if (req.getContentType() !== 'multipart/form-data' ||\n            (req.getContentLength() === 0 && !req.isChunked())) {\n            return (next());\n        }\n\n        var form = new formidable.IncomingForm();\n\n        // enable multiple files on a single upload field\n        // (html5 multiple attribute)\n        form.multiples = options.multiples || false;\n        form.keepExtensions = options.keepExtensions ? true : false;\n\n        if (options.uploadDir) {\n            form.uploadDir = options.uploadDir;\n        }\n\n        if (options.maxFieldsSize) {\n            form.maxFieldsSize = options.maxFieldsSize;\n        }\n\n        if (options.hash) {\n            form.hash = options.hash;\n        }\n\n        form.onPart = function onPart(part) {\n            if (part.filename && options.multipartFileHandler) {\n                options.multipartFileHandler(part, req);\n            } else if (!part.filename && options.multipartHandler) {\n                options.multipartHandler(part, req);\n            } else {\n                form.handlePart(part);\n            }\n        };\n\n        form.parse(req, function (err, fields, files) {\n            if (err) {\n                return (next(new errors.BadRequestError(err.message)));\n            }\n\n            req.body = fields;\n            req.files = files;\n\n            if (options.mapParams !== false) {\n                Object.keys(fields).forEach(function (k) {\n                    if (req.params[k] && !override) {\n                        return;\n                    }\n\n                    req.params[k] = fields[k];\n                });\n\n                if (options.mapFiles) {\n                    var barrier = vasync.barrier();\n                    barrier.on('drain', function () {\n                        return next();\n                    });\n\n                    barrier.start('fs');\n                    Object.keys(files).forEach(function (f) {\n                        if (req.params[f] && !override) {\n                            return;\n                        }\n                        barrier.start('fs' + f);\n                        fs.readFile(files[f].path, function (ex, data) {\n                            barrier.done('fs' + f);\n                            /*\n                             * We want to stop the request here, if there's an\n                             * error trying to read the file from disk.\n                             * Ideally we'd like to stop the other oustanding\n                             * file reads too, but there's no way to cancel in\n                             * flight fs reads.  So we just return an error, and\n                             * be grudgingly let the other file reads finish.\n                             */\n                            if (ex) {\n                                return next(new errors.InternalError(ex,\n                                         'unable to read file' + f));\n                            }\n                            req.params[f] = data;\n                            return (true);\n                        });\n                    });\n                    barrier.done('fs');\n                } else {\n                    return next();\n                }\n            } else {\n                return next();\n            }\n\n        });\n\n        return (false);\n    }\n\n    return (parseMultipartBody);\n}\n\nmodule.exports = multipartBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/fielded_text_body_parser.js":"/**\n * Dependencies\n */\n\n'use strict';\n\nvar csv = require('csv');\nvar assert = require('assert-plus');\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body if the\n * contentType is `text/csv` or `text/tsv`\n * @public\n * @function fieldedTextParser\n * @param    {Object}    options an options object\n * @returns  {Function}\n */\nfunction fieldedTextParser(options) {\n\n    assert.optionalObject(options, 'options');\n    options = options || {};\n\n    function parseFieldedText(req, res, next) {\n\n        var contentType = req.getContentType();\n\n        if (contentType !== 'text/csv' &&\n            contentType !== 'text/tsv' &&\n            contentType !== 'text/tab-separated-values' || !req.body) {\n            next();\n            return;\n        }\n\n\n        var hDelimiter = req.headers['x-content-delimiter'];\n        var hEscape = req.headers['x-content-escape'];\n        var hQuote = req.headers['x-content-quote'];\n        var hColumns = req.headers['x-content-columns'];\n\n\n        var delimiter = (contentType === 'text/tsv') ? '\\t' : ',';\n        delimiter = (hDelimiter) ? hDelimiter : delimiter;\n        var escape = (hEscape) ? hEscape : '\\\\';\n        var quote = (hQuote) ? hQuote : '\"';\n        var columns = (hColumns) ? hColumns : true;\n\n        var parserOptions = {\n            delimiter: delimiter,\n            quote: quote,\n            escape: escape,\n            columns: columns\n        };\n\n        csv.parse(req.body, parserOptions, function (err, parsedBody) {\n            if (err) {\n                return (next(err));\n            }\n\n            // Add an \"index\" property to every row\n            parsedBody.forEach(function (row, index) {\n                row.index = index;\n            });\n            req.body = parsedBody;\n            return (next());\n        });\n\n    }\n\n    return (parseFieldedText);\n\n}\n\nmodule.exports = fieldedTextParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/conditional_request.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar BadRequestError = errors.BadRequestError;\nvar PreconditionFailedError = errors.PreconditionFailedError;\n\nvar IF_MATCH_FAIL = 'if-match \\'%s\\' didn\\'t match etag \\'%s\\'';\nvar IF_NO_MATCH_FAIL = 'if-none-match \\'%s\\' matched etag \\'%s\\'';\nvar IF_MOD_FAIL = 'object was modified at \\'%s\\'; if-modified-since \\'%s\\'';\nvar IF_UNMOD_FAIL = 'object was modified at \\'%s\\'; if-unmodified-since \\'%s\\'';\n\n\n///--- API\n// Reference RFC2616 section 14 for an explanation of what this all does.\n\nfunction checkIfMatch(req, res, next) {\n    var clientETags;\n    var cur;\n    var etag = res.etag || res.getHeader('etag') || '';\n    var ifMatch;\n    var matched = false;\n\n    if ((ifMatch = req.headers['if-match'])) {\n\n        clientETags = ifMatch.split(/\\s*,\\s*/);\n\n        for (var i = 0; i < clientETags.length; i++) {\n            cur = clientETags[i];\n\n            // only strong comparison\n\n            cur = cur.replace(/^W\\//, '');\n            cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n            if (cur === '*' || cur === etag) {\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {\n            var err = new PreconditionFailedError(IF_MATCH_FAIL,\n                ifMatch,\n                etag);\n            return (next(err));\n        }\n    }\n\n    return (next());\n}\n\n\nfunction checkIfNoneMatch(req, res, next) {\n    var clientETags;\n    var cur;\n    var etag = res.etag || res.getHeader('etag') || '';\n    var ifNoneMatch;\n    var matched = false;\n\n    if ((ifNoneMatch = req.headers['if-none-match'])) {\n\n        clientETags = ifNoneMatch.split(/\\s*,\\s*/);\n\n        for (var i = 0; i < clientETags.length; i++) {\n            cur = clientETags[i];\n\n            // ignore weak validation\n            cur = cur.replace(/^W\\//, '');\n            cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n            if (cur === '*' || cur === etag) {\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {\n            return (next());\n        }\n\n        if (req.method !== 'GET' && req.method !== 'HEAD') {\n            var err = new PreconditionFailedError(IF_NO_MATCH_FAIL,\n                ifNoneMatch,\n                etag);\n            return (next(err));\n        }\n\n        res.send(304);\n        return (next(false));\n    }\n\n    return (next());\n}\n\n\nfunction checkIfModified(req, res, next) {\n    var code;\n    var err;\n    var ctime = req.header('if-modified-since');\n    var mtime = res.mtime || res.header('Last-Modified') || '';\n\n    if (!mtime || !ctime) {\n        next();\n        return;\n    }\n\n    try {\n        //\n        // TODO handle Range header modifications\n        //\n        // Note: this is not technically correct as per 2616 -\n        // 2616 only specifies semantics for GET requests, not\n        // any other method - but using if-modified-since with a\n        // PUT or DELETE seems like returning 412 is sane\n        //\n        if (Date.parse(mtime) <= Date.parse(ctime)) {\n            switch (req.method) {\n                case 'GET':\n                case 'HEAD':\n                    code = 304;\n                    break;\n\n                default:\n                    err = new PreconditionFailedError(IF_MOD_FAIL,\n                        mtime,\n                        ctime);\n                    break;\n            }\n        }\n    } catch (e) {\n        next(new BadRequestError(e.message));\n        return;\n    }\n\n    if (code !== undefined) {\n        res.send(code);\n        next(false);\n        return;\n    }\n\n    next(err);\n}\n\n\nfunction checkIfUnmodified(req, res, next) {\n    var err;\n    var ctime = req.headers['if-unmodified-since'];\n    var mtime = res.mtime || res.header('Last-Modified') || '';\n\n    if (!mtime || !ctime) {\n        next();\n        return;\n    }\n\n    try {\n        if (Date.parse(mtime) > Date.parse(ctime)) {\n            err = new PreconditionFailedError(IF_UNMOD_FAIL,\n                mtime,\n                ctime);\n        }\n    } catch (e) {\n        next(new BadRequestError(e.message));\n        return;\n    }\n\n    next(err);\n}\n\n\n///--- Exports\n\n/**\n * Returns a set of plugins that will compare an already set ETag header with\n * the client's If-Match and If-None-Match header, and an already set\n * Last-Modified header with the client's If-Modified-Since and\n * If-Unmodified-Since header.\n * @public\n * @throws {BadRequestError | PreconditionFailedError}\n * @function conditionalRequest\n * @returns  {Array}\n */\nfunction conditionalRequest() {\n    var chain = [\n        checkIfMatch,\n        checkIfNoneMatch,\n        checkIfModified,\n        checkIfUnmodified\n    ];\n    return (chain);\n}\n\nmodule.exports = conditionalRequest;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/cors.js":"// Copyright 2013 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n///--- Globals\n\nvar ALLOW_HEADERS = [\n    'accept',\n    'accept-version',\n    'content-type',\n    'request-id',\n    'origin',\n    'x-api-version',\n    'x-request-id'\n];\n\nvar EXPOSE_HEADERS = [\n    'api-version',\n    'content-length',\n    'content-md5',\n    'content-type',\n    'date',\n    'request-id',\n    'response-time'\n];\n\n// Normal\nvar AC_ALLOW_ORIGIN = 'Access-Control-Allow-Origin';\nvar AC_ALLOW_CREDS = 'Access-Control-Allow-Credentials';\nvar AC_EXPOSE_HEADERS = 'Access-Control-Expose-Headers';\n\n\n///--- Internal Functions\n\nfunction matchOrigin(req, origins) {\n    var origin = req.headers.origin;\n\n    function belongs(o) {\n        if (origin === o || o === '*') {\n            origin = o;\n            return (true);\n        }\n\n        return (false);\n    }\n\n    return ((origin && origins.some(belongs)) ? origin : false);\n}\n\n\n///--- API\n\n/**\n * From http://www.w3.org/TR/cors/#resource-processing-model\n *\n * If \"simple\" request (paraphrased):\n *\n * 1. If the Origin header is not set, or if the value of Origin is not a\n *    case-sensitive match to any values listed in `opts.origins`, do not\n *    send any CORS headers\n *\n * 2. If the resource supports credentials add a single\n *    'Access-Control-Allow-Credentials' header with the value as \"true\", and\n *    ensure 'AC-Allow-Origin' is not '*', but is the request header value,\n *    otherwise add a single Access-Control-Allow-Origin header, with either the\n *    value of the Origin header or the string \"*\" as value\n *\n * 3. Add Access-Control-Expose-Headers as appropriate\n *\n * Pre-flight requests are handled by the router internally\n *\n * @public\n * @function cors\n * @param    {Object}   opts an options object\n * @returns  {Function}\n */\nfunction cors(opts) {\n    assert.optionalObject(opts, 'options');\n    opts = opts || {};\n    assert.optionalArrayOfString(opts.origins, 'options.origins');\n    assert.optionalBool(opts.credentials, 'options.credentials');\n    assert.optionalArrayOfString(opts.headers, 'options.headers');\n\n    cors.credentials = opts.credentials;\n    cors.origins = opts.origins || ['*'];\n\n    var headers = (opts.headers || []).slice(0);\n    var origins = opts.origins || ['*'];\n\n    EXPOSE_HEADERS.forEach(function (h) {\n        if (headers.indexOf(h) === -1) {\n            headers.push(h);\n        }\n    });\n\n    // Handler for simple requests\n    function restifyCORSSimple(req, res, next) {\n        var origin;\n\n        if (!(origin = matchOrigin(req, origins))) {\n            next();\n            return;\n        }\n\n        function corsOnHeader() {\n            origin = req.headers.origin;\n\n            if (opts.credentials) {\n                res.setHeader(AC_ALLOW_ORIGIN, origin);\n                res.setHeader(AC_ALLOW_CREDS, 'true');\n            } else {\n                res.setHeader(AC_ALLOW_ORIGIN, origin);\n            }\n\n            res.setHeader(AC_EXPOSE_HEADERS, headers.join(', '));\n        }\n\n        res.once('header', corsOnHeader);\n        next();\n    }\n\n    return (restifyCORSSimple);\n}\n\n\n///--- Exports\n\nmodule.exports = cors;\n\n// All of these are needed for the pre-flight code over in lib/router.js\ncors.ALLOW_HEADERS = ALLOW_HEADERS;\ncors.EXPOSE_HEADERS = EXPOSE_HEADERS;\ncors.credentials = false;\ncors.origins = [];\ncors.matchOrigin = matchOrigin;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/date.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar InvalidHeaderError = errors.InvalidHeaderError;\nvar RequestExpiredError = errors.RequestExpiredError;\n\nvar BAD_MSG = 'Date header is invalid';\nvar OLD_MSG = 'Date header %s is too old';\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the Date header (if present) and check for\n * an \"expired\" request, where expired means the request originated at a time\n * before ($now - $clockSkew). The default clockSkew allowance is 5m (thanks\n * Kerberos!)\n * @public\n * @function dateParser\n * @throws   {RequestExpiredError | InvalidHeaderError}\n * @param    {Number}    clockSkew optional age of time (in seconds).\n * @returns  {Function}            restify handler.\n */\nfunction dateParser(clockSkew) {\n    if (!clockSkew) {\n        clockSkew = 300;\n    }\n    assert.number(clockSkew, 'clockSkew');\n\n    clockSkew = clockSkew * 1000;\n\n    function parseDate(req, res, next) {\n        if (!req.headers.date) {\n            return (next());\n        }\n\n        var e;\n        var date = req.headers.date;\n        var log = req.log;\n\n        try {\n            var now = Date.now();\n            var sent = new Date(date).getTime();\n\n            if (log.trace()) {\n                log.trace({\n                    allowedSkew: clockSkew,\n                    now: now,\n                    sent: sent\n                }, 'Checking clock skew');\n            }\n\n            if ((now - sent) > clockSkew) {\n                e = new RequestExpiredError(OLD_MSG, date);\n                return (next(e));\n            }\n\n\n        } catch (err) {\n            log.trace({\n                err: err\n            }, 'Bad Date header: %s', date);\n\n            e = new InvalidHeaderError(BAD_MSG, date);\n            return (next(e));\n        }\n\n        return (next());\n    }\n\n    return (parseDate);\n}\n\nmodule.exports = dateParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/jsonp.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar qs = require('qs');\n\n\n///--- API\n\n/**\n * parses the jsonp callback out of the request.\n * @public\n * @function jsonp\n * @returns  {Function}\n */\nfunction jsonp() {\n    function _jsonp(req, res, next) {\n        var q = req.getQuery();\n\n        // If the query plugin wasn't used, we need to hack it in now\n        if (typeof (q) === 'string') {\n            req.query = qs.parse(q);\n        }\n\n        if (req.query.callback || req.query.jsonp) {\n            res.setHeader('Content-Type', 'application/javascript');\n        }\n\n        next();\n    }\n\n    return (_jsonp);\n}\n\n\nmodule.exports = jsonp;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/bunyan.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar shallowCopy = require('../utils').shallowCopy;\n\n\n///--- API\n\n/**\n * attaches bunyan logger to the request.\n * @public\n * @function requestLogger\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction requestLogger(options) {\n    assert.optionalObject(options);\n    options = options || {};\n\n    var props;\n\n    if (options.properties) {\n        props = shallowCopy(options.properties);\n    } else {\n        props = {};\n    }\n\n    if (options.serializers) {\n        props.serializers = options.serializers;\n    }\n\n    var headersToCopy = options.headers || [];\n\n    return function bunyan(req, res, next) {\n        if (!req.log && !options.log) {\n            next();\n            return;\n        }\n\n        var log = req.log || options.log;\n\n        props.req_id = req.getId();\n        headersToCopy.forEach(function (k) {\n\n            if (req.headers[k]) {\n                props[k] = req.headers[k];\n            }\n        });\n        req.log = log.child(props, props.serializers ? false : true);\n\n        if (props.req_id) {\n            delete props.req_id;\n        }\n\n        next();\n    };\n}\n\n\n///--- Exports\n\nmodule.exports = requestLogger;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/gzip.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\n\n\nfunction _writeHead(originalFunction) {\n    this.removeHeader('Content-Length');\n    originalFunction.apply(this, Array.prototype.slice.call(arguments, 1));\n}\n\n///--- API\n\n/**\n * gzips the response.\n * https://github.com/restify/node-restify/issues/284\n * @public\n * @function gzipResponse\n * @param   {Object}   opts an options object\n * @returns {Function}\n */\nfunction gzipResponse(opts) {\n    assert.optionalObject(opts, 'options');\n\n    function gzip(req, res, next) {\n        if (!req.acceptsEncoding('gzip')) {\n            next();\n            return;\n        }\n\n        var gz = zlib.createGzip(opts);\n\n        gz.on('data', res.write.bind(res));\n        gz.once('end', res.end.bind(res));\n        gz.on('drain', res.emit.bind(res, 'drain'));\n\n        var origWrite = res.write;\n        var origEnd = res.end;\n        var origWriteHead = res.writeHead;\n        res.handledGzip = function _handledGzip() {\n            res.write = origWrite;\n            res.end = origEnd;\n            res.writeHead = origWriteHead;\n        };\n\n        res.write = gz.write.bind(gz);\n        res.end = gz.end.bind(gz);\n\n        res.writeHead = _writeHead.bind(res, res.writeHead);\n        res.setHeader('Content-Encoding', 'gzip');\n        next();\n    }\n\n    return (gzip);\n}\n\n\n///--- Exports\n\nmodule.exports = gzipResponse;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/full_response.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar crypto = require('crypto');\n\nvar httpDate = require('../http_date');\n\n\n///--- Globals\n\nvar ALLOW_HEADERS = [\n    'Accept',\n    'Accept-Version',\n    'Content-Length',\n    'Content-MD5',\n    'Content-Type',\n    'Date',\n    'Api-Version',\n    'Response-Time'\n].join(', ');\n\nvar EXPOSE_HEADERS = [\n    'Api-Version',\n    'Request-Id',\n    'Response-Time'\n].join(', ');\n\n\n///--- API\n\nfunction setHeaders(req, res) {\n    var hash;\n    var now = new Date();\n    var methods;\n\n    if (!res.getHeader('Access-Control-Allow-Origin')) {\n        res.setHeader('Access-Control-Allow-Origin', '*');\n    }\n\n    if (!res.getHeader('Access-Control-Allow-Headers')) {\n        res.setHeader('Access-Control-Allow-Headers', ALLOW_HEADERS);\n    }\n\n    if (!res.getHeader('Access-Control-Allow-Methods')) {\n        if (res.methods && res.methods.length > 0) {\n            methods = res.methods.join(', ');\n            res.setHeader('Access-Control-Allow-Methods', methods);\n        }\n    }\n\n    if (!res.getHeader('Access-Control-Expose-Headers')) {\n        res.setHeader('Access-Control-Expose-Headers', EXPOSE_HEADERS);\n    }\n\n    if (!res.getHeader('Connection')) {\n        res.setHeader('Connection',\n            req.isKeepAlive() ? 'Keep-Alive' : 'close');\n    }\n\n    if (res._data && !res.getHeader('Content-MD5')) {\n        hash = crypto.createHash('md5');\n        hash.update(res._data);\n        res.setHeader('Content-MD5', hash.digest('base64'));\n    }\n\n    if (!res.getHeader('Date')) {\n        res.setHeader('Date', httpDate(now));\n    }\n\n    if (res.etag && !res.getHeader('Etag')) {\n        res.setHeader('Etag', res.etag);\n    }\n\n    if (!res.getHeader('Server')) {\n        res.setHeader('Server', res.serverName);\n    }\n\n    if (res.version && !res.getHeader('Api-Version')) {\n        res.setHeader('Api-Version', res.version);\n    }\n\n    if (!res.getHeader('Request-Id')) {\n        res.setHeader('Request-Id', req.getId());\n    }\n\n    if (!res.getHeader('Response-Time')) {\n        res.setHeader('Response-Time', now.getTime() - req._time);\n    }\n\n}\n\n\n/**\n * handles disappeared CORS headers.\n * https://github.com/restify/node-restify/issues/284\n * @public\n * @function fullResponse\n * @returns  {Function}\n */\nfunction fullResponse() {\n    function restifyResponseHeaders(req, res, next) {\n        res.once('header', function () {\n\n            // Restify 1.0 compatibility\n            if (res.defaultResponseFormatters) {\n                res.defaultResponseFormatters(res._data);\n            }\n\n            res.emit('beforeSend', res._data, res._body);\n\n            // end backwards-compatibility\n            return (setHeaders(req, res));\n        });\n\n        return (next());\n    }\n\n    return (restifyResponseHeaders);\n}\n\n\n///--- Exports\n\nmodule.exports = fullResponse;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/query.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar qs = require('qs');\nvar assert = require('assert-plus');\n\nvar EXPOSED_QS_OPTIONS = {\n    allowDots: assert.optionalBool,\n    arrayLimit: assert.optionalNumber,\n    depth: assert.optionalNumber,\n    parameterLimit: assert.optionalNumber,\n    parseArrays: assert.optionalBool,\n    plainObjects: assert.optionalBool,\n    strictNullHandling: assert.optionalBool\n\n    /*\n     * Exclusions (`qs.parse` options that restify does NOT expose):\n     * - `allowPrototypes`: It is strongly suggested against in qs docs.\n     * - `decoder`\n     * - `delimiter`: For query string parsing we shouldn't support anything\n     *   but the default '&'.\n     */\n};\n\n/**\n * Returns a plugin that will parse the query string, and merge the results\n * into req.query.\n *\n * Unless options.mapParams is false, they will also be mapped into req.params.\n * @public\n * @function queryParser\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction queryParser(options) {\n    if (!options) {\n        options = {};\n    }\n    assert.object(options, 'options');\n\n    /*\n     * Releases of restify 4.x up to 4.1.1 used qs@3 which effectively defaulted\n     * to `plainObjects=true` and `allowDots=true`. To maintain backward\n     * compatibility for the restify 4.x stream while using the latest qs\n     * version, we need to maintain those defaults. Note that restify-plugins\n     * changes back to the pre-restify-4.x behaviour. See test/query.test.js\n     * for more details.\n     */\n    var qsOptions = {\n        plainObjects: true,\n        allowDots: true\n    };\n    Object.keys(EXPOSED_QS_OPTIONS).forEach(function (k) {\n        EXPOSED_QS_OPTIONS[k](options[k], k); // assert type of this option\n\n        if (options.hasOwnProperty(k)) {\n            qsOptions[k] = options[k];\n        }\n    });\n\n    function parseQueryString(req, res, next) {\n        if (!req.getQuery()) {\n            req.query = {};\n            return (next());\n        }\n\n        req.query = qs.parse(req.getQuery(), qsOptions);\n\n        if (options.mapParams !== false) {\n            Object.keys(req.query).forEach(function (k) {\n                if (req.params[k] && !options.overrideParams) {\n                    return (false);\n                }\n\n                req.params[k] = req.query[k];\n                return (true);\n            });\n        }\n\n        return (next());\n    }\n\n    return (parseQueryString);\n}\n\nmodule.exports = queryParser;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/request_expiry.js":"'use strict';\n\nvar assert = require('assert-plus');\nvar GatewayTimeoutError = require('./../errors').GatewayTimeoutError;\n\n/**\n * A request expiry will use the headers to tell if the\n * incoming request has expired or not.  The header is\n * expected to be in absolute time since the epoch.\n * @public\n * @function requestExpiry\n * @param    {Object} options        an options object\n * @param    {String} options.header The header key to be used for\n *                                   the expiry time of each request.\n * @returns  {Function}\n */\nfunction requestExpiry(options) {\n    assert.object(options, 'options');\n    assert.string(options.header, 'options.header');\n    var headerKey = options.header;\n\n    return function (req, res, next) {\n        var expiry = req.headers[headerKey];\n\n        if (expiry) {\n            var expiryTime = Number(expiry);\n\n            // The request has expired\n            if (Date.now() > expiryTime) {\n                return next(new GatewayTimeoutError('Request has expired'));\n            }\n        }\n\n        // Happy case\n        return next();\n    };\n}\n\nmodule.exports = requestExpiry;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/pre/pre_path.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Helpers\n\n\n/**\n * Cleans up sloppy URLs on the request object, like /foo////bar/// to /foo/bar.\n * @private\n * @function strip\n * @param    {Object} path a url path to clean up\n * @returns  {String}\n */\nfunction strip(path) {\n    var cur;\n    var next;\n    var str = '';\n\n    for (var i = 0; i < path.length; i++) {\n        cur = path.charAt(i);\n\n        if (i !== path.length - 1) {\n            next = path.charAt(i + 1);\n        }\n\n        if (cur === '/' && (next === '/' || (next === '?' && i > 0))) {\n            continue;\n        }\n\n        str += cur;\n    }\n\n    return (str);\n}\n\n\n/**\n * @public\n * @function sanitizePath\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction sanitizePath(options) {\n    options = options || {};\n\n    function _sanitizePath(req, res, next) {\n        req.url = strip(req.url);\n        next();\n    }\n\n    return (_sanitizePath);\n}\n\n\n///--- Exports\n\nmodule.exports = sanitizePath;\n\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/static.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar escapeRE = require('escape-regexp-component');\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar MethodNotAllowedError = errors.MethodNotAllowedError;\nvar NotAuthorizedError = errors.NotAuthorizedError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\n\n\n///--- Functions\n\n/**\n * serves static files.\n * @public\n * @function serveStatic\n * @param    {Object} opts an options object\n * @throws   {MethodNotAllowedError |\n *            NotAuthorizedError |\n *            ResourceNotFoundError}\n * @returns  {Function}\n */\nfunction serveStatic(opts) {\n    opts = opts || {};\n    assert.object(opts, 'options');\n    assert.string(opts.directory, 'options.directory');\n    assert.optionalNumber(opts.maxAge, 'options.maxAge');\n    assert.optionalObject(opts.match, 'options.match');\n    assert.optionalString(opts.charSet, 'options.charSet');\n    assert.optionalString(opts.file, 'options.file');\n\n    var p = path.normalize(opts.directory).replace(/\\\\/g, '/');\n    var re = new RegExp('^' + escapeRE(p) + '/?.*');\n\n    function serveFileFromStats(file, err, stats, isGzip, req, res, next) {\n        if (err) {\n            next(new ResourceNotFoundError(err,\n                req.path()));\n            return;\n        } else if (!stats.isFile()) {\n            next(new ResourceNotFoundError('%s does not exist', req.path()));\n            return;\n        }\n\n        if (res.handledGzip && isGzip) {\n            res.handledGzip();\n        }\n\n        var fstream = fs.createReadStream(file + (isGzip ? '.gz' : ''));\n        var maxAge = opts.maxAge === undefined ? 3600 : opts.maxAge;\n        fstream.once('open', function (fd) {\n            res.cache({maxAge: maxAge});\n            res.set('Content-Length', stats.size);\n            res.set('Content-Type', mime.lookup(file));\n            res.set('Last-Modified', stats.mtime);\n\n            if (opts.charSet) {\n                var type = res.getHeader('Content-Type') +\n                    '; charset=' + opts.charSet;\n                res.setHeader('Content-Type', type);\n            }\n\n            if (opts.etag) {\n                res.set('ETag', opts.etag(stats, opts));\n            }\n            res.writeHead(200);\n            fstream.pipe(res);\n            fstream.once('end', function () {\n                next(false);\n            });\n        });\n    }\n\n    function serveNormal(file, req, res, next) {\n        fs.stat(file, function (err, stats) {\n            if (!err && stats.isDirectory() && opts.default) {\n                // Serve an index.html page or similar\n                file = path.join(file, opts.default);\n                fs.stat(file, function (dirErr, dirStats) {\n                    serveFileFromStats(file,\n                        dirErr,\n                        dirStats,\n                        false,\n                        req,\n                        res,\n                        next);\n                });\n            } else {\n                serveFileFromStats(file,\n                    err,\n                    stats,\n                    false,\n                    req,\n                    res,\n                    next);\n            }\n        });\n    }\n\n    function serve(req, res, next) {\n        var file;\n\n        if (opts.file) {\n            //serves a direct file\n            file = path.join(opts.directory,\n                decodeURIComponent(opts.file));\n        } else {\n            file = path.join(opts.directory,\n                decodeURIComponent(req.path()));\n        }\n\n        if (req.method !== 'GET' && req.method !== 'HEAD') {\n            next(new MethodNotAllowedError(req.method));\n            return;\n        }\n\n        if (!re.test(file.replace(/\\\\/g, '/'))) {\n            next(new NotAuthorizedError(req.path()));\n            return;\n        }\n\n        if (opts.match && !opts.match.test(file)) {\n            next(new NotAuthorizedError(req.path()));\n            return;\n        }\n\n        if (opts.gzip && req.acceptsEncoding('gzip')) {\n            fs.stat(file + '.gz', function (err, stats) {\n                if (!err) {\n                    res.setHeader('Content-Encoding', 'gzip');\n                    serveFileFromStats(file,\n                        err,\n                        stats,\n                        true,\n                        req,\n                        res,\n                        next);\n                } else {\n                    serveNormal(file, req, res, next);\n                }\n            });\n        } else {\n            serveNormal(file, req, res, next);\n        }\n\n    }\n\n    return (serve);\n}\n\nmodule.exports = serveStatic;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/throttle.js":"// Copyright 2012 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n'use strict';\n\nvar sprintf = require('util').format;\n\nvar assert = require('assert-plus');\nvar LRU = require('lru-cache');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar TooManyRequestsError = errors.TooManyRequestsError;\n\nvar MESSAGE = 'You have exceeded your request rate of %s r/s.';\n\n\n///--- Helpers\n\nfunction xor() {\n    var x = false;\n\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] && !x) {\n            x = true;\n        } else if (arguments[i] && x) {\n            return (false);\n        }\n    }\n    return (x);\n}\n\n\n///--- Internal Class (TokenBucket)\n\n/**\n * An implementation of the Token Bucket algorithm.\n *\n * Basically, in network throttling, there are two \"mainstream\"\n * algorithms for throttling requests, Token Bucket and Leaky Bucket.\n * For restify, I went with Token Bucket.  For a good description of the\n * algorithm, see: http://en.wikipedia.org/wiki/Token_bucket\n *\n * In the options object, you pass in the total tokens and the fill rate.\n * Practically speaking, this means \"allow `fill rate` requests/second,\n * with bursts up to `total tokens`\".  Note that the bucket is initialized\n * to full.\n *\n * Also, in googling, I came across a concise python implementation, so this\n * is just a port of that. Thanks http://code.activestate.com/recipes/511490 !\n *\n * @private\n * @class\n * @param {Object} options contains the parameters:\n *                   - {Number} capacity the maximum burst.\n *                   - {Number} fillRate the rate to refill tokens.\n */\nfunction TokenBucket(options) {\n    assert.object(options, 'options');\n    assert.number(options.capacity, 'options.capacity');\n    assert.number(options.fillRate, 'options.fillRate');\n\n    this.tokens = this.capacity = options.capacity;\n    this.fillRate = options.fillRate;\n    this.time = Date.now();\n}\n\n\n/**\n * Consume N tokens from the bucket.\n *\n * If there is not capacity, the tokens are not pulled from the bucket.\n *\n * @private\n * @function consume\n * @param    {Number}  tokens the number of tokens to pull out.\n * @returns  {Boolean}        true if capacity, false otherwise.\n */\nTokenBucket.prototype.consume = function consume(tokens) {\n    if (tokens <= this._fill()) {\n        this.tokens -= tokens;\n        return (true);\n    }\n\n    return (false);\n};\n\n\n/**\n * Fills the bucket with more tokens.\n *\n * Rather than do some whacky setTimeout() deal, we just approximate refilling\n * the bucket by tracking elapsed time from the last time we touched the bucket.\n *\n * Simply, we set the bucket size to min(totalTokens,\n *                                       current + (fillRate * elapsed time)).\n *\n * @private\n * @function _fill\n * @returns  {Number} the current number of tokens in the bucket.\n */\nTokenBucket.prototype._fill = function _fill() {\n    var now = Date.now();\n\n    // reset account for clock drift (like DST)\n    if (now < this.time) {\n        this.time = now - 1000;\n    }\n\n    if (this.tokens < this.capacity) {\n        var delta = this.fillRate * ((now - this.time) / 1000);\n        this.tokens = Math.min(this.capacity, this.tokens + delta);\n    }\n    this.time = now;\n\n    return (this.tokens);\n};\n\n\n///--- Internal Class (TokenTable)\n/**\n * Just a wrapper over LRU that supports put/get to store token -> bucket\n * mappings.\n * @private\n * @class\n * @param {Object} options      an options object\n * @param {Number} options.size size of the LRU\n */\nfunction TokenTable(options) {\n    assert.object(options, 'options');\n\n    this.table = new LRU(options.size || 10000);\n}\n\n\n/**\n * puts a value in the token table\n * @private\n * @function put\n * @param {String}      key   a name\n * @param {TokenBucket} value a TokenBucket\n * @returns {undefined}\n */\nTokenTable.prototype.put = function put(key, value) {\n    this.table.set(key, value);\n};\n\n\n/**\n * puts a value in the token table\n * @private\n * @function get\n * @param {String} key a key\n * @returns {TokenBucket}\n */\nTokenTable.prototype.get = function get(key) {\n    return (this.table.get(key));\n};\n\n\n///--- Exported API\n\n/**\n * Creates an API rate limiter that can be plugged into the standard\n * restify request handling pipeline.\n *\n * This throttle gives you three options on which to throttle:\n * username, IP address and 'X-Forwarded-For'. IP/XFF is a /32 match,\n * so keep that in mind if using it.  Username takes the user specified\n * on req.username (which gets automagically set for supported Authorization\n * types; otherwise set it yourself with a filter that runs before this).\n *\n * In both cases, you can set a `burst` and a `rate` (in requests/seconds),\n * as an integer/float.  Those really translate to the `TokenBucket`\n * algorithm, so read up on that (or see the comments above...).\n *\n * In either case, the top level options burst/rate set a blanket throttling\n * rate, and then you can pass in an `overrides` object with rates for\n * specific users/IPs.  You should use overrides sparingly, as we make a new\n * TokenBucket to track each.\n *\n * On the `options` object ip and username are treated as an XOR.\n *\n * An example options object with overrides:\n *\n *  {\n *    burst: 10,  // Max 10 concurrent requests (if tokens)\n *    rate: 0.5,  // Steady state: 1 request / 2 seconds\n *    ip: true,   // throttle per IP\n *    overrides: {\n *      '192.168.1.1': {\n *        burst: 0,\n *        rate: 0    // unlimited\n *    }\n *  }\n *\n * @public\n * @function throttle\n * @throws   {TooManyRequestsError}\n * @param    {Object}    options required options with:\n *                   - {Number} burst (required).\n *                   - {Number} rate (required).\n *                   - {Boolean} ip (optional).\n *                   - {Boolean} username (optional).\n *                   - {Boolean} xff (optional).\n *                   - {Object} overrides (optional).\n *                   - {Object} tokensTable: a storage engine this plugin will\n *                              use to store throttling keys -> bucket mappings.\n *                              If you don't specify this, the default is to\n *                              use an in-memory O(1) LRU, with 10k distinct\n *                              keys.  Any implementation just needs to support\n *                              put/get.\n *                   - {Number} maxKeys: If using the default implementation,\n *                              you can specify how large you want the table to\n *                              be.  Default is 10000.\n * @returns  {Function}\n */\nfunction throttle(options) {\n    assert.object(options, 'options');\n    assert.number(options.burst, 'options.burst');\n    assert.number(options.rate, 'options.rate');\n\n    if (!xor(options.ip, options.xff, options.username)) {\n        throw new Error('(ip ^ username ^ xff)');\n    }\n\n    var table = options.tokensTable ||\n        new TokenTable({size: options.maxKeys});\n\n    function rateLimit(req, res, next) {\n        var attr;\n        var burst = options.burst;\n        var rate = options.rate;\n\n        if (options.ip) {\n            attr = req.connection.remoteAddress;\n        } else if (options.xff) {\n            attr = req.headers['x-forwarded-for'];\n        } else if (options.username) {\n            attr = req.username;\n        } else {\n            req.log.warn({config: options},\n                'Invalid throttle configuration');\n            return (next());\n        }\n\n        // Before bothering with overrides, see if this request\n        // even matches\n        if (!attr) {\n            return (next());\n        }\n\n        // Check the overrides\n        if (options.overrides &&\n            options.overrides[attr] &&\n            options.overrides[attr].burst !== undefined &&\n            options.overrides[attr].rate !== undefined) {\n\n            burst = options.overrides[attr].burst;\n            rate = options.overrides[attr].rate;\n        }\n\n        if (!rate || !burst) {\n            return (next());\n        }\n\n        var bucket = table.get(attr);\n\n        if (!bucket) {\n            bucket = new TokenBucket({\n                capacity: burst,\n                fillRate: rate\n            });\n            table.put(attr, bucket);\n        }\n\n        req.log.trace('Throttle(%s): num_tokens= %d',\n            attr, bucket.tokens);\n\n        if (!bucket.consume(1)) {\n            req.log.info({\n                address: req.connection.remoteAddress || '?',\n                method: req.method,\n                url: req.url,\n                user: req.username || '?'\n            }, 'Throttling');\n\n            var msg = sprintf(MESSAGE, rate);\n            return (next(new TooManyRequestsError(msg)));\n        }\n\n        return (next());\n    }\n\n    return (rateLimit);\n}\n\nmodule.exports = throttle;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/pre/pause.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Helpers\n\n/**\n * this pre handler fixes issues with node hanging when an asyncHandler is\n * used prior to bodyParser.\n * https://github.com/restify/node-restify/issues/287\n * https://github.com/restify/node-restify/issues/409\n * https://github.com/restify/node-restify/wiki/1.4-to-2.0-Migration-Tips\n * @public\n * @function pauseStream\n * @param    {Stream} stream the stream to pause\n * @returns  {undefined}\n */\nfunction pauseStream(stream) {\n    function _buffer(chunk) {\n        stream.__buffered.push(chunk);\n    }\n\n    function _catchEnd(chunk) {\n        stream.__rstfy_ended = true;\n    }\n\n    stream.__rstfy_ended = false;\n    stream.__rstfy_paused = true;\n    stream.__buffered = [];\n    stream.on('data', _buffer);\n    stream.once('end', _catchEnd);\n    stream.pause();\n\n    stream._resume = stream.resume;\n    stream.resume = function _rstfy_resume() {\n        if (!stream.__rstfy_paused) {\n            return;\n        }\n\n        stream.removeListener('data', _buffer);\n        stream.removeListener('end', _catchEnd);\n\n        stream.__buffered.forEach(stream.emit.bind(stream, 'data'));\n        stream.__buffered.length = 0;\n\n        stream._resume();\n        stream.resume = stream._resume;\n\n        if (stream.__rstfy_ended) {\n            stream.emit('end');\n        }\n    };\n}\n\n\n///--- Exports\n\nmodule.exports = function pause() {\n\n    function prePause(req, res, next) {\n        pauseStream(req);\n        next();\n    }\n\n    return (prePause);\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/plugins/pre/user_agent.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n///--- API\n\n/**\n * This basically exists for curl.  curl on HEAD requests usually\n * just sits there and hangs, unless you explicitly set\n * Connection:close.  And in general, you probably want to set\n * Connection: close to curl anyway.\n *\n * Also, because curl spits out an annoying message to stderr about\n * remaining bytes if content-length is set, this plugin also drops\n * the content-length header (some user agents handle it and want it,\n * curl does not).\n *\n * To be slightly more generic, the options block takes a user\n * agent regexp, however.\n * @public\n * @function userAgentConnection\n * @param    {Object}   opts an options object\n * @returns  {Function}\n */\nfunction userAgentConnection(opts) {\n    assert.optionalObject(opts, 'options');\n    opts = opts || {};\n    assert.optionalObject(opts.userAgentRegExp, 'options.userAgentRegExp');\n\n    var re = opts.userAgentRegExp;\n\n    if (!re) {\n        re = /^curl.+/;\n    }\n\n    function handleUserAgent(req, res, next) {\n        var ua = req.headers['user-agent'];\n\n        if (ua && re.test(ua)) {\n            res.setHeader('Connection', 'close');\n        }\n\n        if (req.method === 'HEAD') {\n            res.once('header',\n                res.removeHeader.bind(res, 'content-length'));\n        }\n\n        next();\n    }\n\n    return (handleUserAgent);\n}\n\nmodule.exports = userAgentConnection;\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/clients/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar HttpClient = require('./http_client');\nvar JsonClient = require('./json_client');\nvar StringClient = require('./string_client');\n\n\n///--- Exports\n\nmodule.exports = {\n    HttpClient: HttpClient,\n    JsonClient: JsonClient,\n    StringClient: StringClient\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/clients/http_client.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar fs = require('fs');\nvar http = require('http');\nvar https = require('https');\nvar os = require('os');\nvar path = require('path');\nvar querystring = require('querystring');\nvar url = require('url');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar backoff = require('backoff');\nvar mime = require('mime');\nvar once = require('once');\nvar tunnelAgent = require('tunnel-agent');\n\nvar dtrace = require('../dtrace');\nvar errors = require('../errors');\nvar bunyan = require('../bunyan_helper');\n\n// Use native KeepAlive in Node as of 0.11.6\nvar semver = require('semver');\nvar nodeVersion = process.version;\nvar nativeKeepAlive = semver.satisfies(nodeVersion, '>=0.11.6');\nvar KeepAliveAgent;\nvar KeepAliveAgentSecure;\nvar httpMaxSockets = http.globalAgent.maxSockets;\nvar httpsMaxSockets = https.globalAgent.maxSockets;\n\nif (!nativeKeepAlive) {\n    KeepAliveAgent = require('keep-alive-agent');\n    KeepAliveAgentSecure = KeepAliveAgent.Secure;\n} else {\n    KeepAliveAgent = http.Agent;\n    KeepAliveAgentSecure = https.Agent;\n\n    // maxSockets defaults to Infinity, but that doesn't\n    // lend itself well to KeepAlive, since sockets will\n    // never be reused.\n    httpMaxSockets = Math.min(httpMaxSockets, 1024);\n    httpsMaxSockets = Math.min(httpsMaxSockets, 1024);\n}\n\n///--- Globals\n\n// jscs:disable maximumLineLength\nvar VERSION = JSON.parse(fs.readFileSync(path.normalize(__dirname + '/../../package.json'), 'utf8')).version;\n// jscs:enable maximumLineLength\n\n///--- Helpers\n\nfunction cloneRetryOptions(options, defaults) {\n    if (options === false) {\n        return (false);\n    }\n\n    assert.optionalObject(options, 'options.retry');\n    var r = options || {};\n    assert.optionalNumber(r.minTimeout, 'options.retry.minTimeout');\n    assert.optionalNumber(r.maxTimeout, 'options.retry.maxTimeout');\n    assert.optionalNumber(r.retries, 'options.retry.retries');\n    assert.optionalObject(defaults, 'defaults');\n    defaults = defaults || {};\n\n    return ({\n        minTimeout: r.minTimeout || defaults.minTimeout || 1000,\n        maxTimeout: r.maxTimeout || defaults.maxTimeout || Infinity,\n        retries: r.retries || defaults.retries || 4\n    });\n}\n\n\nfunction defaultUserAgent() {\n    var UA = 'restify/' + VERSION +\n        ' (' + os.arch() + '-' + os.platform() + '; ' +\n        'v8/' + process.versions.v8 + '; ' +\n        'OpenSSL/' + process.versions.openssl + ') ' +\n        'node/' + process.versions.node;\n\n    return (UA);\n}\n\n\nfunction ConnectTimeoutError(ms) {\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, ConnectTimeoutError);\n    }\n\n    this.message = 'connect timeout after ' + ms + 'ms';\n    this.name = 'ConnectTimeoutError';\n}\nutil.inherits(ConnectTimeoutError, Error);\n\nfunction RequestTimeoutError(ms) {\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, RequestTimeoutError);\n    }\n\n    this.message = 'request timeout after ' + ms + 'ms';\n    this.name = 'RequestTimeoutError';\n}\nutil.inherits(RequestTimeoutError, Error);\n\nfunction rawRequest(opts, cb) {\n    assert.object(opts, 'options');\n    assert.object(opts.log, 'options.log');\n    assert.func(cb, 'callback');\n\n    cb = once(cb);\n\n    var id = dtrace.nextId();\n    var log = opts.log;\n    var proto = opts.protocol === 'https:' ? https : http;\n    var connectionTimer;\n    var requestTimer;\n    var req;\n\n    if (opts.cert && opts.key) {\n        opts.agent = false;\n    }\n\n    if (opts.connectTimeout) {\n        connectionTimer = setTimeout(function connectTimeout() {\n            connectionTimer = null;\n\n            if (req) {\n                req.abort();\n            }\n\n            var err = new ConnectTimeoutError(opts.connectTimeout);\n            dtrace._rstfy_probes['client-error'].fire(function () {\n                return ([id, err.toString()]);\n            });\n            cb(err, req);\n        }, opts.connectTimeout);\n    }\n\n    dtrace._rstfy_probes['client-request'].fire(function () {\n        return ([\n            opts.method,\n            opts.path,\n            opts.headers,\n            id\n        ]);\n    });\n\n    var emit_result = once(function _emit_result(_err, _req, _res) {\n        _req.emit('result', _err, _res);\n    });\n\n    req = proto.request(opts, function onResponse(res) {\n        clearTimeout(connectionTimer);\n        clearTimeout(requestTimer);\n\n        dtrace._rstfy_probes['client-response'].fire(function () {\n            return ([ id, res.statusCode, res.headers ]);\n        });\n        log.trace({client_res: res}, 'Response received');\n\n        res.log = log;\n\n        var err;\n\n        if (res.statusCode >= 400) {\n            err = errors.codeToHttpError(res.statusCode);\n        }\n\n        req.removeAllListeners('socket');\n\n        emit_result((err || null), req, res);\n    });\n    req.log = log;\n\n    req.on('error', function onError(err) {\n        dtrace._rstfy_probes['client-error'].fire(function () {\n            return ([id, (err || {}).toString()]);\n        });\n        log.trace({err: err}, 'Request failed');\n        clearTimeout(connectionTimer);\n        clearTimeout(requestTimer);\n\n        cb(err, req);\n\n        if (req) {\n            process.nextTick(function () {\n                emit_result(err, req, null);\n            });\n        }\n    });\n\n    req.once('upgrade', function onUpgrade(res, socket, _head) {\n        clearTimeout(connectionTimer);\n        clearTimeout(requestTimer);\n        dtrace._rstfy_probes['client-response'].fire(function () {\n            return ([ id, res.statusCode, res.headers ]);\n        });\n        log.trace({client_res: res}, 'upgrade response received');\n\n        res.log = log;\n\n        var err;\n\n        if (res.statusCode >= 400) {\n            err = errors.codeToHttpError(res.statusCode);\n        }\n\n        req.removeAllListeners('error');\n        req.removeAllListeners('socket');\n        req.emit('upgradeResult', (err || null), res, socket, _head);\n    });\n\n    req.once('socket', function onSocket(socket) {\n        var _socket = socket;\n\n        if (opts.protocol === 'https:' && socket.socket) {\n            _socket = socket.socket;\n        }\n\n        if (_socket.writable && !_socket._connecting) {\n            clearTimeout(connectionTimer);\n            cb(null, req);\n            return;\n        }\n\n        _socket.once('connect', function onConnect() {\n            clearTimeout(connectionTimer);\n\n            if (opts._keep_alive) {\n                _socket.setKeepAlive(true);\n                socket.setKeepAlive(true);\n            }\n\n            if (opts.requestTimeout) {\n                requestTimer = setTimeout(function requestTimeout() {\n                    requestTimer = null;\n\n                    var err = new RequestTimeoutError(opts.requestTimeout);\n                    dtrace._rstfy_probes['client-error'].fire(function () {\n                        return ([id, err.toString()]);\n                    });\n\n                    cb(err, req);\n\n                    if (req) {\n                        req.abort();\n                        process.nextTick(function () {\n                            req.emit('result', err, null);\n                        });\n                    }\n                }, opts.requestTimeout);\n            }\n\n            cb(null, req);\n        });\n    });\n\n    if (opts.signRequest) {\n        opts.signRequest(req);\n    }\n\n    if (log.trace()) {\n        log.trace({client_req: opts}, 'request sent');\n    }\n} // end `rawRequest`\n\n\n//  Check if url is excluded by the no_proxy environment variable\nfunction isProxyForURL(address) {\n    var noProxy = process.env.NO_PROXY || process.env.no_proxy || null;\n\n    // wildcard\n    if (noProxy === '*') {\n        return (null);\n    }\n\n    // otherwise, parse the noProxy value to see if it applies to the URL\n    if (noProxy !== null) {\n        var noProxyItem, hostname, port, noProxyItemParts,\n            noProxyHost, noProxyPort, noProxyList;\n\n        // canonicalize the hostname\n        /* JSSTYLED */\n        hostname = address.hostname.replace(/^\\.*/, '.').toLowerCase();\n        noProxyList = noProxy.split(',');\n\n        for (var i = 0, len = noProxyList.length; i < len; i++) {\n            noProxyItem = noProxyList[i].trim().toLowerCase();\n\n            // no_proxy can be granular at the port level\n            if (noProxyItem.indexOf(':') > -1) {\n                noProxyItemParts = noProxyItem.split(':', 2);\n                /* JSSTYLED */\n                noProxyHost = noProxyItemParts[0].replace(/^\\.*/, '.');\n                noProxyPort = noProxyItemParts[1];\n                port = address.port ||\n                    (address.protocol === 'https:' ? '443' : '80');\n\n                // match - ports are same and host ends with no_proxy entry.\n                if (port === noProxyPort &&\n                    hostname.indexOf(noProxyHost) ===\n                    hostname.length - noProxyHost.length) {\n                    return (null);\n                }\n            } else {\n                /* JSSTYLED */\n                noProxyItem = noProxyItem.replace(/^\\.*/, '.');\n                var isMatchedAt = hostname.indexOf(noProxyItem);\n\n                if (isMatchedAt > -1 &&\n                    isMatchedAt === hostname.length - noProxyItem.length) {\n                    return (null);\n                }\n            }\n        }\n    }\n    return (true);\n}\n///--- API\n\nfunction HttpClient(options) {\n    assert.object(options, 'options');\n    assert.optionalObject(options.headers, 'options.headers');\n    assert.object(options.log, 'options.log');\n    assert.optionalFunc(options.signRequest, 'options.signRequest');\n    assert.optionalString(options.socketPath, 'options.socketPath');\n    assert.optionalString(options.url, 'options.url');\n\n    EventEmitter.call(this);\n\n    var self = this;\n\n    this.agent = options.agent;\n    this.ca = options.ca;\n    this.cert = options.cert;\n    this.ciphers = options.ciphers;\n    this.connectTimeout = options.connectTimeout || false;\n    this.requestTimeout = options.requestTimeout || false;\n    this.headers = options.headers || {};\n    this.log = options.log;\n\n    if (!this.log.serializers) {\n        // Ensure logger has a reasonable serializer for `client_res`\n        // and `client_req` logged in this module.\n        this.log = this.log.child({serializers: bunyan.serializers});\n    }\n    this.key = options.key;\n    this.name = options.name || 'HttpClient';\n    this.passphrase = options.passphrase;\n    this.pfx = options.pfx;\n\n    if (options.rejectUnauthorized !== undefined) {\n        this.rejectUnauthorized = options.rejectUnauthorized;\n    } else {\n        this.rejectUnauthorized = true;\n    }\n\n    this.retry = cloneRetryOptions(options.retry);\n    this.signRequest = options.signRequest || false;\n    this.socketPath = options.socketPath || false;\n    this.url = options.url ? url.parse(options.url) : {};\n\n    if (process.env.https_proxy) {\n        this.proxy = url.parse(process.env.https_proxy);\n    } else if (process.env.http_proxy) {\n        this.proxy = url.parse(process.env.http_proxy);\n    } else if (options.proxy) {\n        this.proxy = options.proxy;\n    } else {\n        this.proxy = false;\n    }\n\n    if (this.proxy && !isProxyForURL(self.url)) {\n        this.proxy = false;\n    }\n\n    if (options.accept) {\n        if (options.accept.indexOf('/') === -1) {\n            options.accept = mime.lookup(options.accept);\n        }\n\n        this.headers.accept = options.accept;\n    }\n\n    if (options.contentType) {\n        if (options.contentType.indexOf('/') === -1) {\n            options.type = mime.lookup(options.contentType);\n        }\n\n        this.headers['content-type'] = options.contentType;\n    }\n\n    if (options.userAgent !== false) {\n        this.headers['user-agent'] = options.userAgent ||\n            defaultUserAgent();\n    }\n\n    if (options.version) {\n        this.headers['accept-version'] = options.version;\n    }\n\n    if (this.agent === undefined) {\n        var Agent;\n        var maxSockets;\n\n        if (this.proxy) {\n            if (this.url.protocol === 'https:') {\n                if (this.proxy.protocol === 'https:') {\n                    Agent = tunnelAgent.httpsOverHttps;\n                } else {\n                    Agent = tunnelAgent.httpsOverHttp;\n                }\n            } else {\n                if (this.proxy.protocol === 'https:') {\n                    Agent = tunnelAgent.httpOverHttps;\n                } else {\n                    Agent = tunnelAgent.httpOverHttp;\n                }\n            }\n        } else if (this.url.protocol === 'https:') {\n            Agent = KeepAliveAgentSecure;\n            maxSockets = httpsMaxSockets;\n        } else {\n            Agent = KeepAliveAgent;\n            maxSockets = httpMaxSockets;\n        }\n\n        if (this.proxy) {\n            this.agent = new Agent({\n                proxy: self.proxy,\n                rejectUnauthorized: self.rejectUnauthorized,\n                ca: self.ca\n            });\n        } else {\n            this.agent = new Agent({\n                cert: self.cert,\n                ca: self.ca,\n                ciphers: self.ciphers,\n                key: self.key,\n                maxSockets: maxSockets,\n\n                // require('keep-alive-agent')\n                maxKeepAliveRequests: 0,\n                maxKeepAliveTime: 0,\n\n                // native keepalive\n                keepAliveMsecs: 1000,\n                keepAlive: true,\n\n                passphrase: self.passphrase,\n                pfx: self.pfx,\n                rejectUnauthorized: self.rejectUnauthorized\n            });\n            this._keep_alive = true;\n        }\n    }\n}\nutil.inherits(HttpClient, EventEmitter);\n\nmodule.exports = HttpClient;\n\n\nHttpClient.prototype.close = function close() {\n    var sockets = this.agent.sockets;\n    Object.keys((sockets || {})).forEach(function (k) {\n        if (Array.isArray(sockets[k])) {\n            sockets[k].forEach(function (s) {\n                s.end();\n            });\n        }\n    });\n\n    sockets = this.agent.idleSockets || this.agent.freeSockets;\n    Object.keys((sockets || {})).forEach(function (k) {\n        sockets[k].forEach(function (s) {\n            s.end();\n        });\n    });\n};\n\n\nHttpClient.prototype.del = function del(options, callback) {\n    var opts = this._options('DELETE', options);\n\n    return (this.read(opts, callback));\n};\n\n\nHttpClient.prototype.get = function get(options, callback) {\n    var opts = this._options('GET', options);\n\n    return (this.read(opts, callback));\n};\n\n\nHttpClient.prototype.head = function head(options, callback) {\n    var opts = this._options('HEAD', options);\n\n    return (this.read(opts, callback));\n};\n\nHttpClient.prototype.opts = function http_options(options, callback) {\n    var _opts = this._options('OPTIONS', options);\n\n    return (this.read(_opts, callback));\n};\n\n\nHttpClient.prototype.post = function post(options, callback) {\n    var opts = this._options('POST', options);\n\n    return (this.request(opts, callback));\n};\n\n\nHttpClient.prototype.put = function put(options, callback) {\n    var opts = this._options('PUT', options);\n\n    return (this.request(opts, callback));\n};\n\n\nHttpClient.prototype.patch = function patch(options, callback) {\n    var opts = this._options('PATCH', options);\n\n\n    return (this.request(opts, callback));\n};\n\n\nHttpClient.prototype.read = function read(options, callback) {\n    var r = this.request(options, function readRequestCallback(err, req) {\n        if (!err) {\n            req.end();\n        }\n\n        return (callback(err, req));\n    });\n    return (r);\n};\n\n\nHttpClient.prototype.basicAuth = function basicAuth(username, password) {\n    if (username === false) {\n        delete this.headers.authorization;\n    } else {\n        assert.string(username, 'username');\n        assert.string(password, 'password');\n\n        var buffer = new Buffer(username + ':' + password, 'utf8');\n        this.headers.authorization = 'Basic ' +\n            buffer.toString('base64');\n    }\n\n    return (this);\n};\n\n\nHttpClient.prototype.request = function request(opts, cb) {\n    assert.object(opts, 'options');\n    assert.func(cb, 'callback');\n\n    cb = once(cb);\n\n    if (opts.retry === false) {\n        rawRequest(opts, cb);\n        return;\n    }\n\n    var call;\n    var retry = cloneRetryOptions(opts.retry);\n\n    opts._keep_alive = this._keep_alive;\n    call = backoff.call(rawRequest, opts, cb);\n    call.setStrategy(new backoff.ExponentialStrategy({\n        initialDelay: retry.minTimeout,\n        maxDelay: retry.maxTimeout\n    }));\n    call.failAfter(retry.retries);\n    call.on('backoff', this.emit.bind(this, 'attempt'));\n\n    call.start();\n};\n\n\nHttpClient.prototype._options = function (method, options) {\n    if (typeof (options) !== 'object') {\n        options = { path: options };\n    }\n\n    var self = this;\n    var opts = {\n        agent: options.agent !== undefined ? options.agent : self.agent,\n        ca: options.ca || self.ca,\n        cert: options.cert || self.cert,\n        ciphers: options.ciphers || self.ciphers,\n        connectTimeout: options.connectTimeout || self.connectTimeout,\n        requestTimeout: options.requestTimeout || self.requestTimeout,\n        headers: options.headers || {},\n        key: options.key || self.key,\n        log: options.log || self.log,\n        method: method,\n        passphrase: options.passphrase || self.passphrase,\n        path: options.path || self.path,\n        pfx: options.pfx || self.pfx,\n        rejectUnauthorized: options.rejectUnauthorized ||\n            self.rejectUnauthorized,\n        retry: options.retry !== false ? options.retry : false,\n        signRequest: options.signRequest || self.signRequest\n    };\n\n    if (!opts.retry && opts.retry !== false) {\n        opts.retry = self.retry;\n    }\n\n\n    // Backwards compatibility with restify < 1.0\n    if (options.query &&\n        Object.keys(options.query).length &&\n        opts.path.indexOf('?') === -1) {\n        opts.path += '?' + querystring.stringify(options.query);\n    }\n\n    if (this.socketPath) {\n        opts.socketPath = this.socketPath;\n    }\n\n    Object.keys(this.url).forEach(function (k) {\n        if (!opts[k]) {\n            opts[k] = self.url[k];\n        }\n    });\n\n    Object.keys(self.headers).forEach(function (k) {\n        if (!opts.headers[k]) {\n            opts.headers[k] = self.headers[k];\n        }\n    });\n\n    if (!opts.headers.date) {\n        opts.headers.date = new Date().toUTCString();\n    }\n\n    if (method === 'GET' || method === 'HEAD' || method === 'DELETE') {\n        if (opts.headers['content-type']) {\n            delete opts.headers['content-type'];\n        }\n\n        if (opts.headers['content-md5']) {\n            delete opts.headers['content-md5'];\n        }\n\n        if (opts.headers['content-length'] && method !== 'DELETE') {\n            delete opts.headers['content-length'];\n        }\n\n        if (opts.headers['transfer-encoding']) {\n            delete opts.headers['transfer-encoding'];\n        }\n    }\n\n    return (opts);\n};\n\n// vim: set ts=4 sts=4 sw=4 et:\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/dtrace.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n\n///--- Globals\n\n'use strict';\n\nvar ID = 0;\nvar MAX_INT = Math.pow(2, 32) - 1;\n\nvar PROBES = {\n    // server_name, route_name, id, method, url, headers (json)\n    'route-start': ['char *', 'char *', 'int', 'char *', 'char *', 'json'],\n\n    // server_name, route_name, handler_name, id\n    'handler-start': ['char *', 'char *', 'char *', 'int'],\n\n    // server_name, route_name, handler_name, id\n    'handler-done': ['char *', 'char *', 'char *', 'int'],\n\n    // server_name, route_name, id, statusCode, headers (json)\n    'route-done': ['char *', 'char *', 'int', 'int', 'json'],\n\n\n    // Client probes\n    // method, url, headers, id\n    'client-request': ['char *', 'char *', 'json', 'int'],\n\n    // id, statusCode, headers\n    'client-response': ['int', 'int', 'json'],\n\n    // id, Error.toString()\n    'client-error': ['id', 'char *']\n};\nvar PROVIDER;\n\n\n///--- API\n\nmodule.exports = (function exportStaticProvider() {\n    if (!PROVIDER) {\n        try {\n            var dtrace = require('dtrace-provider');\n            PROVIDER = dtrace.createDTraceProvider('restify');\n        } catch (e) {\n            PROVIDER = {\n                fire: function () {\n                },\n                enable: function () {\n                },\n                addProbe: function () {\n                    var p = {\n                        fire: function () {\n                        }\n                    };\n                    return (p);\n                },\n                removeProbe: function () {\n                },\n                disable: function () {\n                }\n            };\n        }\n\n        PROVIDER._rstfy_probes = {};\n\n        Object.keys(PROBES).forEach(function (p) {\n            var args = PROBES[p].splice(0);\n            args.unshift(p);\n\n            var probe = PROVIDER.addProbe.apply(PROVIDER, args);\n            PROVIDER._rstfy_probes[p] = probe;\n        });\n\n        PROVIDER.enable();\n\n        PROVIDER.nextId = function nextId() {\n            if (++ID >= MAX_INT) {\n                ID = 1;\n            }\n\n            return (ID);\n        };\n    }\n\n    return (PROVIDER);\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/bunyan_helper.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar Stream = require('stream').Stream;\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar bunyan = require('bunyan');\nvar LRU = require('lru-cache');\nvar uuid = require('node-uuid');\n\n\n///--- Globals\n\nvar sprintf = util.format;\nvar DEFAULT_REQ_ID = uuid.v4();\nvar STR_FMT = '[object %s<level=%d, limit=%d, maxRequestIds=%d>]';\n\n\n///--- Helpers\n\n/**\n * appends streams\n * @private\n * @function appendStream\n * @param    {Stream}    streams the stream to append to\n * @param    {Stream}    s       the stream to append\n * @returns  {undefined}\n */\nfunction appendStream(streams, s) {\n    assert.arrayOfObject(streams, 'streams');\n    assert.object(s, 'stream');\n\n    if (s instanceof Stream) {\n        streams.push({\n            raw: false,\n            stream: s\n        });\n    } else {\n        assert.optionalBool(s.raw, 'stream.raw');\n        assert.object(s.stream, 'stream.stream');\n        streams.push(s);\n    }\n}\n\n\n///--- API\n/**\n * A Bunyan stream to capture records in a ring buffer and only pass through\n * on a higher-level record. E.g. buffer up all records but only dump when\n * getting a WARN or above.\n * @public\n * @class\n * @param {Object} opts                contains the parameters:\n * @param {Object} opts.stream         The stream to which to write when\n *                                     dumping captured records. One of `stream`\n *                                     or `streams` must be specified.\n * @param {Array} opts.streams         One of `stream` or `streams` must be\n *                                     specified.\n * @param {Number | String} opts.level The level at which to trigger dumping\n *                                     captured records. Defaults to\n *                                     bunyan.WARN.\n * @param {Number} opts.maxRecords     Number of records to capture. Default\n *                                     100.\n * @param {Number} opts.maxRequestIds  Number of simultaneous request id\n *                                     capturing buckets to maintain. Default\n *                                     1000.\n * @param {Boolean} opts.dumpDefault   If true, then dump captured records on\n *                                     the *default* request id when dumping.\n *                                     I.e. dump records logged without\n *                                     \"req_id\" field. Default false.\n */\nfunction RequestCaptureStream(opts) {\n    assert.object(opts, 'options');\n    assert.optionalObject(opts.stream, 'options.stream');\n    assert.optionalArrayOfObject(opts.streams, 'options.streams');\n    assert.optionalNumber(opts.level, 'options.level');\n    assert.optionalNumber(opts.maxRecords, 'options.maxRecords');\n    assert.optionalNumber(opts.maxRequestIds, 'options.maxRequestIds');\n    assert.optionalBool(opts.dumpDefault, 'options.dumpDefault');\n\n    var self = this;\n    Stream.call(this);\n\n    this.level = opts.level ? bunyan.resolveLevel(opts.level) : bunyan.WARN;\n    this.limit = opts.maxRecords || 100;\n    this.maxRequestIds = opts.maxRequestIds || 1000;\n    this.requestMap = LRU({\n        max: self.maxRequestIds\n    });\n    this.dumpDefault = opts.dumpDefault;\n\n    this._offset = -1;\n    this._rings = [];\n\n    this.streams = [];\n\n    if (opts.stream) {\n        appendStream(this.streams, opts.stream);\n    }\n\n    if (opts.streams) {\n        opts.streams.forEach(appendStream.bind(null, this.streams));\n    }\n\n    this.haveNonRawStreams = false;\n\n    for (var i = 0; i < this.streams.length; i++) {\n        if (!this.streams[i].raw) {\n            this.haveNonRawStreams = true;\n            break;\n        }\n    }\n}\nutil.inherits(RequestCaptureStream, Stream);\n\n\n/**\n * write to the stream\n * @public\n * @function write\n * @param    {Object}    record a bunyan log record\n * @returns  {undefined}\n */\nRequestCaptureStream.prototype.write = function write(record) {\n    var req_id = record.req_id || DEFAULT_REQ_ID;\n    var ring;\n    var self = this;\n\n    if (!(ring = this.requestMap.get(req_id))) {\n        if (++this._offset > this.maxRequestIds) {\n            this._offset = 0;\n        }\n\n        if (this._rings.length <= this._offset) {\n            this._rings.push(new bunyan.RingBuffer({\n                limit: self.limit\n            }));\n        }\n\n        ring = this._rings[this._offset];\n        ring.records.length = 0;\n        this.requestMap.set(req_id, ring);\n    }\n\n    assert.ok(ring, 'no ring found');\n\n    if (record.level >= this.level) {\n        var i, r, ser;\n\n        for (i = 0; i < ring.records.length; i++) {\n            r = ring.records[i];\n\n            if (this.haveNonRawStreams) {\n                ser = JSON.stringify(r,\n                    bunyan.safeCycles()) + '\\n';\n            }\n            self.streams.forEach(function (s) {\n                s.stream.write(s.raw ? r : ser);\n            });\n        }\n        ring.records.length = 0;\n\n        if (this.dumpDefault) {\n            var defaultRing = self.requestMap.get(DEFAULT_REQ_ID);\n\n            for (i = 0; i < defaultRing.records.length; i++) {\n                r = defaultRing.records[i];\n\n                if (this.haveNonRawStreams) {\n                    ser = JSON.stringify(r,\n                        bunyan.safeCycles()) + '\\n';\n                }\n                self.streams.forEach(function (s) {\n                    s.stream.write(s.raw ? r : ser);\n                });\n            }\n            defaultRing.records.length = 0;\n        }\n    } else {\n        ring.write(record);\n    }\n};\n\n\n/**\n * toString() serialization\n * @public\n * @function toString\n * @returns  {String}\n */\nRequestCaptureStream.prototype.toString = function toString() {\n    return (sprintf(STR_FMT,\n        this.constructor.name,\n        this.level,\n        this.limit,\n        this.maxRequestIds));\n};\n\n\n///--- Serializers\n\nvar SERIALIZERS = {\n    err: bunyan.stdSerializers.err,\n    req: bunyan.stdSerializers.req,\n    res: bunyan.stdSerializers.res,\n    client_req: clientReq,\n    client_res: clientRes\n};\n\n\n/**\n * a request serializer. returns a stripped down object for logging.\n * @private\n * @function clientReq\n * @param    {Object} req the request object\n * @returns  {Object}\n */\nfunction clientReq(req) {\n    if (!req) {\n        return (req);\n    }\n\n    var host;\n\n    try {\n        host = req.host.split(':')[0];\n    } catch (e) {\n        host = false;\n    }\n\n    return ({\n        method: req ? req.method : false,\n        url: req ? req.path : false,\n        address: host,\n        port: req ? req.port : false,\n        headers: req ? req.headers : false\n    });\n}\n\n\n/**\n * a response serializer. returns a stripped down object for logging.\n * @private\n * @function clientRes\n * @param    {Object} res the response object\n * @returns  {Object}\n */\nfunction clientRes(res) {\n    if (!res || !res.statusCode) {\n        return (res);\n    }\n\n    return ({\n        statusCode: res.statusCode,\n        headers: res.headers\n    });\n}\n\n\n/**\n * create a bunyan logger\n * @public\n * @function createLogger\n * @param    {String}     name of the logger\n * @returns  {Object}          bunyan logger\n */\nfunction createLogger(name) {\n    return (bunyan.createLogger({\n        name: name,\n        serializers: SERIALIZERS,\n        streams: [\n            {\n                level: 'warn',\n                stream: process.stderr\n            },\n            {\n                level: 'debug',\n                type: 'raw',\n                stream: new RequestCaptureStream({\n                    stream: process.stderr\n                })\n            }\n        ]\n    }));\n}\n\n\n\n///--- Exports\n\nmodule.exports = {\n    RequestCaptureStream: RequestCaptureStream,\n    serializers: SERIALIZERS,\n    createLogger: createLogger\n\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/clients/json_client.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar util = require('util');\n\nvar assert = require('assert-plus');\n\nvar codeToHttpError = require('../errors/http_error').codeToHttpError;\nvar RestError = require('../errors').RestError;\nvar StringClient = require('./string_client');\n\n\n///--- API\n\nfunction JsonClient(options) {\n    assert.object(options, 'options');\n\n    options.accept = 'application/json';\n    options.name = options.name || 'JsonClient';\n    options.contentType = 'application/json';\n\n    StringClient.call(this, options);\n\n    this._super = StringClient.prototype;\n}\nutil.inherits(JsonClient, StringClient);\n\nmodule.exports = JsonClient;\n\n\nJsonClient.prototype.write = function write(options, body, callback) {\n    assert.ok(body !== undefined, 'body');\n    assert.object(body, 'body');\n\n    body = JSON.stringify(body !== null ? body : {});\n    return (this._super.write.call(this, options, body, callback));\n};\n\n\nJsonClient.prototype.parse = function parse(req, callback) {\n    var log = this.log;\n\n    function parseResponse(err, req2, res, data) {\n        var obj;\n\n        try {\n            if (data && !/^\\s*$/.test(data)) {\n                obj = JSON.parse(data);\n            }\n        } catch (e) {\n            // Not really sure what else we can do here, besides\n            // make the client just keep going.\n            log.trace(e, 'Invalid JSON in response');\n        }\n        obj = obj || {};\n\n        if (res && res.statusCode >= 400) {\n            // Upcast error to a RestError (if we can)\n            // Be nice and handle errors like\n            // { error: { code: '', message: '' } }\n            // in addition to { code: '', message: '' }.\n            if (obj.code || (obj.error && obj.error.code)) {\n                var _c = obj.code ||\n                    (obj.error ? obj.error.code : '') ||\n                    '';\n                var _m = obj.message ||\n                    (obj.error ? obj.error.message : '') ||\n                    '';\n\n                err = new RestError({\n                    message: _m,\n                    restCode: _c,\n                    statusCode: res.statusCode\n                });\n                err.name = err.restCode;\n\n                if (!/Error$/.test(err.name)) {\n                    err.name += 'Error';\n                }\n            } else if (!err) {\n                err = codeToHttpError(res.statusCode,\n                    obj.message || '', data);\n            }\n        }\n\n        if (err) {\n            err.body = obj;\n        }\n\n        callback((err || null), req2, res, obj);\n    }\n\n    return (this._super.parse.call(this, req, parseResponse));\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/clients/string_client.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\nvar qs = require('querystring');\nvar util = require('util');\n\nvar HttpClient = require('./http_client');\n\n\n///--- Helpers\n\n\n///--- API\n\nfunction StringClient(options) {\n    assert.object(options, 'options');\n    assert.optionalObject(options.gzip, 'options.gzip');\n\n    options.accept = options.accept || 'text/plain';\n    options.name = options.name || 'StringClient';\n    options.contentType =\n        options.contentType || 'application/x-www-form-urlencoded';\n\n    HttpClient.call(this, options);\n    this.gzip = options.gzip;\n}\nutil.inherits(StringClient, HttpClient);\n\nmodule.exports = StringClient;\n\n\nStringClient.prototype.post = function post(options, body, callback) {\n    var opts = this._options('POST', options);\n\n    if (typeof (body) === 'function') {\n        callback = body;\n        body = null;\n    }\n\n    return (this.write(opts, body, callback));\n};\n\n\nStringClient.prototype.put = function put(options, body, callback) {\n    var opts = this._options('PUT', options);\n\n    if (typeof (body) === 'function') {\n        callback = body;\n        body = null;\n    }\n\n    return (this.write(opts, body, callback));\n};\n\n\nStringClient.prototype.patch = function patch(options, body, callback) {\n    var opts = this._options('PATCH', options);\n\n    if (typeof (body) === 'function') {\n        callback = body;\n        body = null;\n    }\n\n    return (this.write(opts, body, callback));\n};\n\n\nStringClient.prototype.read = function read(options, callback) {\n    var self = this;\n    this.request(options, function _parse(err, req) {\n        if (err) {\n            return (callback(err, req));\n        }\n\n        req.once('result', self.parse(req, callback));\n        return (req.end());\n    });\n    return (this);\n};\n\n\nStringClient.prototype.write = function write(options, body, callback) {\n    if (body !== null && typeof (body) !== 'string') {\n        body = qs.stringify(body);\n    }\n\n    var self = this;\n\n    function _write(data) {\n        if (data) {\n            var hash = crypto.createHash('md5');\n            hash.update(data, 'utf8');\n            options.headers['content-md5'] = hash.digest('base64');\n        }\n\n        self.request(options, function (err, req) {\n            if (err) {\n                callback(err, req);\n                return;\n            }\n\n            req.once('result', self.parse(req, callback));\n            req.end(data);\n        });\n    }\n\n    options.headers = options.headers || {};\n\n    if (this.gzip) {\n        options.headers['accept-encoding'] = 'gzip';\n    }\n\n    if (body) {\n        if (this.gzip) {\n            options.headers['content-encoding'] = 'gzip';\n            zlib.gzip(body, function (err, data) {\n                if (err) {\n                    callback(err, null);\n                    return;\n                }\n\n                options.headers['content-length'] = data.length;\n                _write(data);\n            });\n        } else {\n            options.headers['content-length'] =\n                Buffer.byteLength(body);\n            _write(body);\n        }\n    } else {\n        _write();\n    }\n\n    return (this);\n};\n\n\nStringClient.prototype.parse = function parse(req, callback) {\n    function parseResponse(err, res) {\n        var body = '';\n        var gz;\n        var hash;\n        var md5;\n\n        function done() {\n            res.log.trace('body received:\\n%s', body);\n            res.body = body;\n\n            if (hash && md5 !== hash.digest('base64')) {\n                err = new Error('BadDigest');\n                callback(err, req, res);\n                return;\n            }\n\n            if (err) {\n                err.body = body;\n                err.message = body;\n            }\n\n            callback(err, req, res, body);\n        }\n\n        if (res) {\n            md5 = res.headers['content-md5'];\n\n            if (md5 && req.method !== 'HEAD' && res.statusCode !== 206) {\n                hash = crypto.createHash('md5');\n            }\n\n            if (res.headers['content-encoding'] === 'gzip') {\n                gz = zlib.createGunzip();\n                gz.on('data', function (chunk) {\n                    body += chunk.toString('utf8');\n                });\n                gz.once('end', done);\n                res.once('end', gz.end.bind(gz));\n            } else {\n                res.setEncoding('utf8');\n                res.once('end', done);\n            }\n\n            res.on('data', function onData(chunk) {\n                if (hash) {\n                    hash.update(chunk);\n                }\n\n                if (gz) {\n                    gz.write(chunk);\n                } else {\n                    body += chunk;\n                }\n            });\n\n        } else {\n            callback(err, req, null, null);\n        }\n    }\n\n    return (parseResponse);\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/request.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar http = require('http');\nvar url = require('url');\nvar sprintf = require('util').format;\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\nvar Negotatior = require('negotiator');\nvar uuid = require('node-uuid');\n\nvar dtrace = require('./dtrace');\n\n\n///--- Globals\n\nvar Request = http.IncomingMessage;\n\n\n///-- Helpers\n/**\n * creates and sets negotiator on request if one doesn't already exist,\n * then returns it.\n * @private\n * @function negotiator\n * @param    {Object} req the request object\n * @returns  {Object}     a negotiator\n */\nfunction negotiator(req) {\n    var h = req.headers;\n\n    if (!req._negotatiator) {\n        req._negotiator = new Negotatior({\n            headers: {\n                accept: h.accept || '*/*',\n                'accept-encoding': h['accept-encoding'] ||\n                    'identity'\n            }\n        });\n    }\n\n    return (req._negotiator);\n}\n\n\n///--- API\n\n///--- Patches\n\n/**\n * builds an absolute URI for the request.\n * @private\n * @function absoluteUri\n * @param    {String} path a url path\n * @returns  {String}\n */\nRequest.prototype.absoluteUri = function absoluteUri(path) {\n    assert.string(path, 'path');\n\n    var protocol = this.secure ? 'https://' : 'http://';\n    var hostname = this.headers.host;\n    return (url.resolve(protocol + hostname + this.path() + '/', path));\n};\n\n\n/**\n * checks if the accept header is present and has the value requested.\n * e.g., req.accepts('html');\n * @public\n * @function accepts\n * @param    {String | Array} types an array of accept type headers\n * @returns  {Boolean}\n */\nRequest.prototype.accepts = function accepts(types) {\n    if (typeof (types) === 'string') {\n        types = [types];\n    }\n\n    types = types.map(function (t) {\n        assert.string(t, 'type');\n\n        if (t.indexOf('/') === -1) {\n            t = mime.lookup(t);\n        }\n        return (t);\n    });\n\n    negotiator(this);\n\n    return (this._negotiator.preferredMediaType(types));\n};\n\n\n/**\n * checks if the request accepts the encoding types.\n * @public\n * @function acceptsEncoding\n * @param    {String | Array} types an array of accept type headers\n * @returns  {Boolean}\n */\nRequest.prototype.acceptsEncoding = function acceptsEncoding(types) {\n    if (typeof (types) === 'string') {\n        types = [types];\n    }\n\n    assert.arrayOfString(types, 'types');\n\n    negotiator(this);\n\n    return (this._negotiator.preferredEncoding(types));\n};\n\n\n/**\n * gets the content-length header off the request.\n * @public\n * @function getContentLength\n * @returns {Number}\n */\nRequest.prototype.getContentLength = function getContentLength() {\n    if (this._clen !== undefined) {\n        return (this._clen === false ? undefined : this._clen);\n    }\n\n    // We should not attempt to read and parse the body of an\n    // Upgrade request, so force Content-Length to zero:\n    if (this.isUpgradeRequest()) {\n        return (0);\n    }\n\n    var len = this.header('content-length');\n\n    if (!len) {\n        this._clen = false;\n    } else {\n        this._clen = parseInt(len, 10);\n    }\n\n    return (this._clen === false ? undefined : this._clen);\n};\n/**\n * pass through to getContentLength\n * @public\n * @function contentLength\n * @returns {Number}\n */\nRequest.prototype.contentLength = Request.prototype.getContentLength;\n\n\n/**\n * gets the content-type header.\n * @public\n * @function getContentType\n * @returns {String}\n */\nRequest.prototype.getContentType = function getContentType() {\n    if (this._contentType !== undefined) {\n        return (this._contentType);\n    }\n\n    var index;\n    var type = this.headers['content-type'];\n\n    if (!type) {\n        // RFC2616 section 7.2.1\n        this._contentType = 'application/octet-stream';\n    } else {\n        if ((index = type.indexOf(';')) === -1) {\n            this._contentType = type;\n        } else {\n            this._contentType = type.substring(0, index);\n        }\n    }\n\n    // #877 content-types need to be case insensitive.\n    this._contentType = this._contentType.toLowerCase();\n\n    return (this._contentType);\n};\nRequest.prototype.contentType = Request.prototype.getContentType;\n\n\n/**\n * gets the _date property off the request. was created when the request\n * was setup.\n * @private\n * @function date\n * @returns  {Date}\n */\nRequest.prototype.date = function date() {\n    if (this._date !== undefined) {\n        return (this._date);\n    }\n\n    this._date = new Date(this._time);\n    return (this._date);\n};\n\n\n/**\n * retrieves the complete URI requested by the client.\n * @public\n * @function getHref\n * @returns {String}\n */\nRequest.prototype.getHref = function getHref() {\n    return (this.getUrl().href);\n};\nRequest.prototype.href = Request.prototype.getHref;\n\n\n/**\n * retrieves the request uuid. was created when the request was setup.\n * @public\n * @function getId\n * @returns  {String}\n */\nRequest.prototype.getId = function getId() {\n    if (this._id !== undefined) {\n        return (this._id);\n    }\n\n    this._id = this.headers['request-id'] ||\n        this.headers['x-request-id'] ||\n        uuid.v4();\n\n    return (this._id);\n};\nRequest.prototype.id = Request.prototype.getId;\n\n\n/**\n * retrieves the cleaned up url path.\n * e.g., /foo?a=1  =>  /foo\n * @public\n * @function getPath\n * @returns  {String}\n */\nRequest.prototype.getPath = function getPath() {\n    return (this.getUrl().pathname);\n};\nRequest.prototype.path = Request.prototype.getPath;\n\n\n/**\n * returns the raw query string\n * @public\n * @function getQuery\n * @returns  {String}\n */\nRequest.prototype.getQuery = function getQuery() {\n    // always return a string, because this is the raw query string.\n    // if the queryParser plugin is used, req.query will provide an empty\n    // object fallback.\n    return (this.getUrl().query || '');\n};\nRequest.prototype.query = Request.prototype.getQuery;\n\n\n/**\n * returns ms since epoch when request was setup.\n * @public\n * @function time\n * @returns  {Number}\n */\nRequest.prototype.time = function time() {\n    return (this._time);\n};\n\n\n/**\n * returns a parsed URL object.\n * @public\n * @function getUrl\n * @returns  {Object}\n */\nRequest.prototype.getUrl = function getUrl() {\n    if (this._cacheURL !== this.url) {\n        this._url = url.parse(this.url);\n        this._cacheURL = this.url;\n    }\n    return (this._url);\n};\n\n\n/**\n * returns the accept-version header.\n * @public\n * @function getVersion\n * @returns  {String}\n */\nRequest.prototype.getVersion = function getVersion() {\n    if (this._version !== undefined) {\n        return (this._version);\n    }\n\n    this._version =\n        this.headers['accept-version'] ||\n            this.headers['x-api-version'] ||\n            '*';\n\n    return (this._version);\n};\nRequest.prototype.version = Request.prototype.getVersion;\n\nRequest.prototype.matchedVersion = function matchedVersion() {\n    if (this._matchedVersion !== undefined) {\n        return (this._matchedVersion);\n    } else {\n        return (this.version());\n    }\n};\n\n/**\n * returns any header off the request. also, 'correct' any\n * correctly spelled 'referrer' header to the actual spelling used.\n * @public\n * @function header\n * @param    {String} name  the name of the header\n * @param    {String} value default value if header isn't found on the req\n * @returns  {String}\n */\nRequest.prototype.header = function header(name, value) {\n    assert.string(name, 'name');\n\n    name = name.toLowerCase();\n\n    if (name === 'referer' || name === 'referrer') {\n        name = 'referer';\n    }\n\n    return (this.headers[name] || value);\n};\n\n\n/**\n * returns any trailer header off the request. also, 'correct' any\n * correctly spelled 'referrer' header to the actual spelling used.\n * @public\n * @function trailer\n * @param    {String} name  the name of the header\n * @param    {String} value default value if header isn't found on the req\n * @returns  {String}\n */\nRequest.prototype.trailer = function trailer(name, value) {\n    assert.string(name, 'name');\n    name = name.toLowerCase();\n\n    if (name === 'referer' || name === 'referrer') {\n        name = 'referer';\n    }\n\n    return ((this.trailers || {})[name] || value);\n};\n\n\n/**\n * Check if the incoming request contains the Content-Type header field, and\n * if it contains the given mime type.\n * @public\n * @function is\n * @param    {String} type  a content-type header value\n * @returns  {Boolean}\n */\nRequest.prototype.is = function is(type) {\n    assert.string(type, 'type');\n\n    var contentType = this.getContentType();\n    var matches = true;\n\n    if (!contentType) {\n        return (false);\n    }\n\n    if (type.indexOf('/') === -1) {\n        type = mime.lookup(type);\n    }\n\n    if (type.indexOf('*') !== -1) {\n        type = type.split('/');\n        contentType = contentType.split('/');\n        matches &= (type[0] === '*' || type[0] === contentType[0]);\n        matches &= (type[1] === '*' || type[1] === contentType[1]);\n    } else {\n        matches = (contentType === type);\n    }\n\n    return (matches);\n};\n\n\n/**\n * Check if the incoming request is chunked.\n * @public\n * @function isChunked\n * @returns  {Boolean}\n */\nRequest.prototype.isChunked = function isChunked() {\n    return (this.headers['transfer-encoding'] === 'chunked');\n};\n\n\n/**\n * Check if the incoming request is kept alive.\n * @public\n * @function isKeepAlive\n * @returns  {Boolean}\n */\nRequest.prototype.isKeepAlive = function isKeepAlive() {\n    if (this._keepAlive !== undefined) {\n        return (this._keepAlive);\n    }\n\n    if (this.headers.connection) {\n        this._keepAlive = /keep-alive/i.test(this.headers.connection);\n    } else {\n        this._keepAlive = this.httpVersion === '1.0' ? false : true;\n    }\n\n    return (this._keepAlive);\n};\n\n\n/**\n * Check if the incoming request is encrypted.\n * @public\n * @function isSecure\n * @returns  {Boolean}\n */\nRequest.prototype.isSecure = function isSecure() {\n    if (this._secure !== undefined) {\n        return (this._secure);\n    }\n\n    this._secure = this.connection.encrypted ? true : false;\n    return (this._secure);\n};\n\n\n/**\n * Check if the incoming request has been upgraded.\n * @public\n * @function isUpgradeRequest\n * @returns  {Boolean}\n */\nRequest.prototype.isUpgradeRequest = function isUpgradeRequest() {\n    if (this._upgradeRequest !== undefined) {\n        return (this._upgradeRequest);\n    } else {\n        return (false);\n    }\n};\n\n\n/**\n * Check if the incoming request is an upload verb.\n * @public\n * @function isUpload\n * @returns  {Boolean}\n */\nRequest.prototype.isUpload = function isUpload() {\n    var m = this.method;\n    return (m === 'PATCH' || m === 'POST' || m === 'PUT');\n};\n\n\n/**\n * toString serialization\n * @public\n * @function toString\n * @returns  {String}\n */\nRequest.prototype.toString = function toString() {\n    var headers = '';\n    var self = this;\n    var str;\n\n    Object.keys(this.headers).forEach(function (k) {\n        headers += sprintf('%s: %s\\n', k, self.headers[k]);\n    });\n\n    str = sprintf('%s %s HTTP/%s\\n%s',\n        this.method,\n        this.url,\n        this.httpVersion,\n        headers);\n\n    return (str);\n};\n\n\n/**\n * retrieves the user-agent header.\n * @public\n * @function userAgent\n * @returns  {String}\n */\nRequest.prototype.userAgent = function userAgent() {\n    return (this.headers['user-agent']);\n};\n\n\n/**\n * Start the timer for a request handler function. You must explicitly invoke\n * endHandlerTimer() after invoking this function. Otherwise timing information\n * will be inaccurate.\n * @public\n * @function startHandlerTimer\n * @param    {String}    handlerName The name of the handler.\n * @returns  {undefined}\n */\nRequest.prototype.startHandlerTimer = function startHandlerTimer(handlerName) {\n    var self = this;\n\n    // For nested handlers, we prepend the top level handler func name\n    var name = (self._currentHandler === handlerName ?\n                handlerName : self._currentHandler + '-' + handlerName);\n\n    if (!self._timerMap) {\n        self._timerMap = {};\n    }\n\n    self._timerMap[name] = process.hrtime();\n\n    dtrace._rstfy_probes['handler-start'].fire(function () {\n        return ([\n            self.serverName,\n            self._currentRoute, // set in server._run\n            name,\n            self._dtraceId\n        ]);\n    });\n};\n\n\n/**\n * Stop the timer for a request handler function.\n * @public\n * @function endHandlerTimer\n * @param    {String}    handlerName The name of the handler.\n * @returns  {undefined}\n */\nRequest.prototype.endHandlerTimer = function endHandlerTimer(handlerName) {\n    var self = this;\n\n    // For nested handlers, we prepend the top level handler func name\n    var name = (self._currentHandler === handlerName ?\n                handlerName : self._currentHandler + '-' + handlerName);\n\n    if (!self.timers) {\n        self.timers = [];\n    }\n\n    self._timerMap[name] = process.hrtime(self._timerMap[name]);\n    self.timers.push({\n        name: name,\n        time: self._timerMap[name]\n    });\n\n    dtrace._rstfy_probes['handler-done'].fire(function () {\n        return ([\n            self.serverName,\n            self._currentRoute, // set in server._run\n            name,\n            self._dtraceId\n        ]);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/response.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar http = require('http');\nvar sprintf = require('util').format;\nvar url = require('url');\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\n\nvar httpDate = require('./http_date');\nvar utils = require('./utils');\nvar errors = require('./errors');\n\n///--- Globals\n\nvar InternalServerError = errors.InternalServerError;\n\nvar Response = http.ServerResponse;\n\n\n///--- API\n\n/**\n * sets the cache-control header. `type` defaults to _public_,\n * and options currently only takes maxAge.\n * @public\n * @function cache\n * @param    {String} type    value of the header\n * @param    {Object} options an options object\n * @returns  {String}         the value set to the header\n */\nResponse.prototype.cache = function cache(type, options) {\n    if (typeof (type) !== 'string') {\n        options = type;\n        type = 'public';\n    }\n\n    if (options && options.maxAge !== undefined) {\n        assert.number(options.maxAge, 'options.maxAge');\n        type += ', max-age=' + options.maxAge;\n    }\n\n    return (this.header('Cache-Control', type));\n};\n\n\n/**\n * turns off all cache related headers.\n * @public\n * @function noCache\n * @returns  {Object} self, the response object\n */\nResponse.prototype.noCache = function noCache() {\n    // HTTP 1.1\n    this.header('Cache-Control', 'no-cache, no-store, must-revalidate');\n\n    // HTTP 1.0\n    this.header('Pragma', 'no-cache');\n\n    // Proxies\n    this.header('Expires', '0');\n\n    return (this);\n};\n\n\n/**\n * Appends the provided character set to the response's Content-Type.\n * e.g., res.charSet('utf-8');\n * @public\n * @function charSet\n * @param    {String} type char-set value\n * @returns  {Object} self, the response object\n */\nResponse.prototype.charSet = function charSet(type) {\n    assert.string(type, 'charset');\n\n    this._charSet = type;\n\n    return (this);\n};\n\n\n/**\n * the response formatter. formats the response in preparation to send it off.\n * callback only used in async formatters. restify does not ship with any\n * async formatters currently.\n * @public\n * @function format\n * @param    {Object | String} body the response body to format\n * @param    {Function}        cb   callback function\n * @returns  {undefined}\n */\nResponse.prototype.format = function format(body, cb) {\n    var log = this.log;\n    var formatter;\n    var type = this.contentType || this.getHeader('Content-Type');\n    var self = this;\n\n    if (!type) {\n        if (this.req.accepts(this.acceptable)) {\n            type = this.req.accepts(this.acceptable);\n        }\n\n        if (!type) {\n            // The importance of a status code outside of the\n            // 2xx range probably outweighs that of unable being to\n            // format the response body\n            if (this.statusCode >= 200 && this.statusCode < 300) {\n                this.statusCode = 406;\n            }\n\n            return cb(null);\n        }\n    } else if (type.indexOf(';') !== '-1') {\n        type = type.split(';')[0];\n    }\n\n    if (!(formatter = this.formatters[type])) {\n        if (type.indexOf('/') === -1) {\n            type = mime.lookup(type);\n        }\n\n        if (this.acceptable.indexOf(type) === -1) {\n            type = 'application/octet-stream';\n        }\n\n        formatter = this.formatters[type] || this.formatters['*/*'];\n\n        // this is a catastrophic case - should always fall back on octet-stream\n        // but if for some reason that's gone, return a 500.\n        if (!formatter) {\n            log.warn({\n                req: self.req\n            }, 'no formatter found. Returning 500.');\n            this.statusCode = 500;\n            return cb(null);\n        }\n    }\n\n    if (this._charSet) {\n        type = type + '; charset=' + this._charSet;\n    }\n\n    this.setHeader('Content-Type', type);\n\n    if (body instanceof Error && body.statusCode !== undefined) {\n        this.statusCode = body.statusCode;\n    }\n    return (formatter.call(this, this.req, this, body, cb));\n};\n\n\n/**\n * retrieves a header off the response.\n * @public\n * @function get\n * @param    {Object} name the header name\n * @returns  {String}\n */\nResponse.prototype.get = function get(name) {\n    assert.string(name, 'name');\n\n    return (this.getHeader(name));\n};\n\n\n/**\n * retrieves all headers off the response.\n * @public\n * @function getHeaders\n * @returns  {Object}\n */\nResponse.prototype.getHeaders = function getHeaders() {\n    return (this._headers || {});\n};\nResponse.prototype.headers = Response.prototype.getHeaders;\n\n\n/**\n * sets headers on the response.\n * @public\n * @function header\n * @param    {String} name  the name of the header\n * @param    {String} value the value of the header\n * @returns  {Object}\n */\nResponse.prototype.header = function header(name, value) {\n    assert.string(name, 'name');\n\n    if (value === undefined) {\n        return (this.getHeader(name));\n    }\n\n    if (value instanceof Date) {\n        value = httpDate(value);\n    } else if (arguments.length > 2) {\n        // Support res.header('foo', 'bar %s', 'baz');\n        var arg = Array.prototype.slice.call(arguments).slice(2);\n        value = sprintf(value, arg);\n    }\n\n    var current = this.getHeader(name);\n\n    // #779, don't use comma separated values for set-cookie, see\n    // http://tools.ietf.org/html/rfc6265#section-3\n    if (current && name.toLowerCase() !== 'set-cookie') {\n        if (Array.isArray(current)) {\n            current.push(value);\n            value = current;\n        } else {\n            value = [current, value];\n        }\n    }\n\n    this.setHeader(name, value);\n    return (value);\n};\n\n\n/**\n * short hand method for:\n *     res.contentType = 'json';\n *     res.send({hello: 'world'});\n * @public\n * @function json\n * @param    {Number} code    http status code\n * @param    {Object} object  value to json.stringify\n * @param    {Object} headers headers to set on the response\n * @returns  {Object}\n */\nResponse.prototype.json = function json(code, object, headers) {\n    if (!/application\\/json/.test(this.header('content-type'))) {\n        this.header('Content-Type', 'application/json');\n    }\n\n    return (this.send(code, object, headers));\n};\n\n\n/**\n * sets the link heaader.\n * @public\n * @function link\n * @param    {String} l   the link key\n * @param    {String} rel the link value\n * @returns  {String}     the header value set to res\n */\nResponse.prototype.link = function link(l, rel) {\n    assert.string(l, 'link');\n    assert.string(rel, 'rel');\n\n    var _link = sprintf('<%s>; rel=\"%s\"', l, rel);\n    return (this.header('Link', _link));\n};\n\n\n/**\n * sends the response object. convenience method that handles:\n *     writeHead(), write(), end()\n * @public\n * @function send\n * @param    {Number} code                      http status code\n * @param    {Object | Buffer | Error} body     the content to send\n * @param    {Object}                  headers  any add'l headers to set\n * @returns  {Object}                           self, the response object\n */\nResponse.prototype.send = function send(code, body, headers) {\n    var isHead = (this.req.method === 'HEAD');\n    var log = this.log;\n    var self = this;\n\n    if (code === undefined) {\n        this.statusCode = 200;\n    } else if (code.constructor.name === 'Number') {\n        this.statusCode = code;\n\n        if (body instanceof Error) {\n            body.statusCode = this.statusCode;\n        }\n    } else {\n        headers = body;\n        body = code;\n        code = null;\n    }\n\n    headers = headers || {};\n\n    if (log.trace()) {\n        var _props = {\n            code: self.statusCode,\n            headers: headers\n        };\n\n        if (body instanceof Error) {\n            _props.err = body;\n        } else {\n            _props.body = body;\n        }\n        log.trace(_props, 'response::send entered');\n    }\n\n    this._body = body;\n\n    function _cb(err, _body) {\n        // the problem here is that if the formatter throws an error, we can't\n        // actually format the error again, since the formatter already failed.\n        // So all we can do is send back a 500 with no body, since we don't\n        // know at this point what format to send the error as. Additionally,\n        // the current 'after' event is emitted _before_ we send the response,\n        // so there's no way to re-emit the error here. TODO: clean up 'after'\n        // even emitter so we pick up the error here.\n        if (err) {\n            self._data = null;\n            self.statusCode = 500;\n            log.error(err, 'unable to format response');\n        } else {\n            self._data = _body;\n        }\n        Object.keys(headers).forEach(function (k) {\n            self.setHeader(k, headers[k]);\n        });\n\n        self.writeHead(self.statusCode);\n\n        if (self._data && !(isHead || code === 204 || code === 304)) {\n            self.write(self._data);\n        }\n\n        self.end();\n\n        if (log.trace()) {\n            log.trace({res: self}, 'response sent');\n        }\n    }\n\n    if (body !== undefined) {\n        this.format(body, _cb);\n    } else {\n        _cb(null, null);\n    }\n\n    return (this);\n};\n\n\n/**\n * sets a header on the response.\n * @public\n * @function set\n * @param    {String} name name of the header\n * @param    {String} val  value of the header\n * @returns  {Object}      self, the response object\n */\nResponse.prototype.set = function set(name, val) {\n    var self = this;\n\n    if (arguments.length === 2) {\n        assert.string(name, 'name');\n        this.header(name, val);\n    } else {\n        assert.object(name, 'object');\n        Object.keys(name).forEach(function (k) {\n            self.header(k, name[k]);\n        });\n    }\n\n    return (this);\n};\n\n\n/**\n * sets the http status code on the response.\n * @public\n * @function status\n * @param    {Number} code http status code\n * @returns  {Number}     the status code passed in\n */\nResponse.prototype.status = function status(code) {\n    assert.number(code, 'code');\n\n    this.statusCode = code;\n    return (code);\n};\n\n\n/**\n * toString() serialization.\n * @public\n * @function toString\n * @returns  {String}\n */\nResponse.prototype.toString = function toString() {\n    var headers = this.getHeaders();\n    var headerString = '';\n    var str;\n\n    Object.keys(headers).forEach(function (k) {\n        headerString += k + ': ' + headers[k] + '\\n';\n    });\n    str = sprintf('HTTP/1.1 %s %s\\n%s',\n        this.statusCode,\n        http.STATUS_CODES[this.statusCode],\n        headerString);\n\n    return (str);\n};\n\nif (!Response.prototype.hasOwnProperty('_writeHead')) {\n    Response.prototype._writeHead = Response.prototype.writeHead;\n}\n\n\n/**\n * pass through to native response.writeHead()\n * @public\n * @function writeHead\n * @returns  {undefined}\n */\nResponse.prototype.writeHead = function restifyWriteHead() {\n    this.emit('header');\n\n    if (this.statusCode === 204 || this.statusCode === 304) {\n        this.removeHeader('Content-Length');\n        this.removeHeader('Content-MD5');\n        this.removeHeader('Content-Type');\n        this.removeHeader('Content-Encoding');\n    }\n\n    this._writeHead.apply(this, arguments);\n};\n\n\n/*\n * redirect is sugar method for redirecting. takes a few different signatures:\n * 1) res.redirect(301, 'www.foo.com', next);\n * 2) res.redirect('www.foo.com', next);\n * 3) res.redirect({...}, next);\n * `next` is mandatory, to complete the response and trigger audit logger.\n * @public\n * @param    {Number | String}   arg1 the status code or url to direct to\n * @param    {String | Function} arg2 the url to redirect to, or `next` fn\n * @param    {Function}          arg3 `next` fn\n * @function redirect\n * @return   {undefined}\n */\nResponse.prototype.redirect = function redirect(arg1, arg2, arg3) {\n\n    var self = this;\n    var statusCode = 302;\n    var finalUri;\n    var next;\n\n    // 1) this is signature 1, where an explicit status code is passed in.\n    //    MUST guard against null here, passing null is likely indicative\n    //    of an attempt to call res.redirect(null, next);\n    //    as a way to do a reload of the current page.\n    if (arg1 && !isNaN(arg1)) {\n        statusCode = arg1;\n        finalUri = arg2;\n        next = arg3;\n    }\n\n    // 2) this is signaure number 2\n    else if (typeof (arg1) === 'string') {\n        // otherwise, it's a string, and use it directly\n        finalUri = arg1;\n        next = arg2;\n    }\n\n    // 3) signature number 3, using an options object.\n    else if (typeof (arg1) === 'object') {\n\n        // set next, then go to work.\n        next = arg2;\n\n        var req = self.req;\n        var opt = arg1 || {};\n        var currentFullPath = req.href();\n        var secure = (opt.hasOwnProperty('secure')) ?\n                        opt.secure :\n                        req.isSecure();\n\n        // if hostname is passed in, use that as the base,\n        // otherwise fall back on current url.\n        var parsedUri = url.parse(opt.hostname || currentFullPath, true);\n\n        // create the object we'll use to format for the final uri.\n        // this object will eventually get passed to url.format().\n        // can't use parsedUri to seed it, as it confuses the url module\n        // with some existing parsed state. instead, we'll pick the things\n        // we want and use that as a starting point.\n        finalUri = {\n            port: parsedUri.port,\n            hostname: parsedUri.hostname,\n            query: parsedUri.query,\n            pathname: parsedUri.pathname\n        };\n\n        // start building url based on options.\n        // first, set protocol.\n        finalUri.protocol = (secure === true) ? 'https' : 'http';\n\n        // then set host\n        if (opt.hostname) {\n            finalUri.hostname = opt.hostname;\n        }\n\n        // then set current path after the host\n        if (opt.pathname) {\n            finalUri.pathname = opt.pathname;\n        }\n\n        // then add query params\n        if (opt.query) {\n            if (opt.overrideQuery === true) {\n                finalUri.query = opt.query;\n            } else {\n                finalUri.query = utils.mergeQs(opt.query, finalUri.query);\n            }\n        }\n\n        // change status code to 301 permanent if specified\n        if (opt.permanent) {\n            statusCode = 301;\n        }\n    }\n\n    // if we're missing a next we should probably throw. if user wanted\n    // to redirect but we were unable to do so, we should not continue\n    // down the handler stack.\n    assert.func(next, 'res.redirect() requires a next param');\n\n    // if we are missing a finalized uri\n    // by this point, pass an error to next.\n    if (!finalUri) {\n        return (next(new InternalServerError('could not construct url')));\n    }\n\n    // now we're done constructing url, send the res\n    self.send(statusCode, null, {\n        location: url.format(finalUri)\n    });\n\n    // tell server to stop processing the handler stack.\n    return (next(false));\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/router.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar url = require('url');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar LRU = require('lru-cache');\nvar Negotiator = require('negotiator');\nvar semver = require('semver');\n\nvar cors = require('./plugins/cors');\nvar errors = require('./errors');\nvar utils = require('./utils');\n\n\n///--- Globals\n\nvar DEF_CT = 'application/octet-stream';\n\nvar BadRequestError = errors.BadRequestError;\nvar InternalError = errors.InternalError;\nvar InvalidArgumentError = errors.InvalidArgumentError;\nvar InvalidVersionError = errors.InvalidVersionError;\nvar MethodNotAllowedError = errors.MethodNotAllowedError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\nvar UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;\n\nvar shallowCopy = utils.shallowCopy;\n\n\n///--- Helpers\n\n\n/**\n * given a request, try to match it against the regular expression to\n * get the route params.\n * i.e., /foo/:param1/:param2\n * @private\n * @function matchURL\n * @param    {String | RegExp} re   a string or regular expression\n * @param    {Object}          req  the request object\n * @returns  {Object}\n */\nfunction matchURL(re, req) {\n    var i = 0;\n    var result = re.exec(req.path());\n    var params = {};\n\n    if (!result) {\n        return (false);\n    }\n\n    // This means the user original specified a regexp match, not a url\n    // string like /:foo/:bar\n    if (!re.restifyParams) {\n        for (i = 1; i < result.length; i++) {\n            params[(i - 1)] = result[i];\n        }\n\n        return (params);\n    }\n\n    // This was a static string, like /foo\n    if (re.restifyParams.length === 0) {\n        return (params);\n    }\n\n    // This was the \"normal\" case, of /foo/:id\n    re.restifyParams.forEach(function (p) {\n        if (++i < result.length) {\n            params[p] = decodeURIComponent(result[i]);\n        }\n    });\n\n    return (params);\n}\n\n\n/**\n * called while installing routes. attempts to compile the passed in string\n * or regexp and register it.\n * @private\n * @function compileURL\n * @param    {Object} options an options object\n * @returns  {RegExp}\n */\nfunction compileURL(options) {\n    if (options.url instanceof RegExp) {\n        return (options.url);\n    }\n    assert.string(options.url, 'url');\n\n    var params = [];\n    var pattern = '^';\n    var re;\n    var _url = url.parse(options.url).pathname;\n    _url.split('/').forEach(function (frag) {\n        if (frag.length <= 0) {\n            return (false);\n        }\n\n        pattern += '\\\\/+';\n\n        if (frag.charAt(0) === ':') {\n            var label = frag;\n            var index = frag.indexOf('(');\n            var subexp;\n\n            if (index === -1) {\n                if (options.urlParamPattern) {\n                    subexp = options.urlParamPattern;\n                } else {\n                    subexp = '[^/]*';\n                }\n            } else {\n                label = frag.substring(0, index);\n                subexp = frag.substring(index + 1, frag.length - 1);\n            }\n            pattern += '(' + subexp + ')';\n            params.push(label.slice(1));\n        } else {\n            pattern += frag;\n        }\n        return (true);\n    });\n\n    if (pattern === '^') {\n        pattern += '\\\\/';\n    }\n    pattern += '$';\n\n    re = new RegExp(pattern, options.flags);\n    re.restifyParams = params;\n\n    return (re);\n}\n\n\n///--- API\n\n/**\n * Router class handles mapping of http verbs and a regexp path,\n * to an array of handler functions.\n * @class\n * @public\n * @param  {Object} options an options object\n */\nfunction Router(options) {\n    assert.object(options, 'options');\n    assert.object(options.log, 'options.log');\n\n    EventEmitter.call(this);\n\n    this.cache = LRU({max: 100});\n    this.contentType = options.contentType || [];\n\n    if (!Array.isArray(this.contentType)) {\n        this.contentType = [this.contentType];\n    }\n    assert.arrayOfString(this.contentType, 'options.contentType');\n\n    this.log = options.log;\n    this.mounts = {};\n    this.name = 'RestifyRouter';\n\n    // A list of methods to routes\n    this.routes = {\n        DELETE: [],\n        GET: [],\n        HEAD: [],\n        OPTIONS: [],\n        PATCH: [],\n        POST: [],\n        PUT: []\n    };\n\n    // So we can retrun 405 vs 404, we maintain a reverse mapping of URLs\n    // to method\n    this.reverse = {};\n\n    this.versions = options.versions || options.version || [];\n\n    if (!Array.isArray(this.versions)) {\n        this.versions = [this.versions];\n    }\n    assert.arrayOfString(this.versions, 'options.versions');\n\n    this.versions.forEach(function (v) {\n        if (semver.valid(v)) {\n            return (true);\n        }\n\n        throw new InvalidArgumentError('%s is not a valid semver', v);\n    });\n    this.versions.sort();\n\n}\nutil.inherits(Router, EventEmitter);\n\nmodule.exports = Router;\n\n/**\n * takes an object of route params and query params, and 'renders' a URL.\n * @public\n * @function render\n * @param    {String} routeName the route name\n * @param    {Object} params    an object of route params\n * @param    {Object} query     an object of query params\n * @returns  {String}\n */\nRouter.prototype.render = function render(routeName, params, query) {\n    function pathItem(match, key) {\n        if (params.hasOwnProperty(key) === false) {\n            throw new Error('Route <' + routeName +\n                            '> is missing parameter <' +\n                            key + '>');\n        }\n        return ('/' + encodeURIComponent(params[key]));\n    }\n\n    function queryItem(key) {\n        return (encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));\n    }\n\n    var routeKey = routeName.replace(/\\W/g, '').toLowerCase();\n    var route = this.mounts[routeKey];\n\n    if (!route) {\n        return (null);\n    }\n\n    var _path = route.spec.path;\n    var _url = _path.replace(/\\/:([A-Za-z0-9_]+)(\\([^\\\\]+?\\))?/g, pathItem);\n    var items = Object.keys(query || {}).map(queryItem);\n    var queryString = items.length > 0 ? ('?' + items.join('&')) : '';\n    return (_url + queryString);\n};\n\n\n/**\n * adds a route.\n * @public\n * @function mount\n * @param    {Object} options an options object\n * @returns  {String}         returns the route name if creation is successful.\n */\nRouter.prototype.mount = function mount(options) {\n    assert.object(options, 'options');\n    assert.string(options.method, 'options.method');\n    assert.string(options.name, 'options.name');\n\n    var exists;\n    var name = options.name;\n    var route;\n    var routes = this.routes[options.method];\n    var self = this;\n    var type = options.contentType || self.contentType;\n    var versions = options.versions || options.version || self.versions;\n\n    if (type) {\n        if (!Array.isArray(type)) {\n            type = [type];\n        }\n        type.filter(function (t) {\n            return (t);\n        }).sort().join();\n    }\n\n    if (versions) {\n        if (!Array.isArray(versions)) {\n            versions = [versions];\n        }\n        versions.sort();\n    }\n\n    exists = routes.some(function (r) {\n        return (r.name === name);\n    });\n\n    if (exists) {\n        return (false);\n    }\n\n    route = {\n        name: name,\n        method: options.method,\n        path: compileURL({\n            url: options.path || options.url,\n            flags: options.flags,\n            urlParamPattern: options.urlParamPattern\n        }),\n        spec: options,\n        types: type,\n        versions: versions\n    };\n    routes.push(route);\n\n    if (!this.reverse[route.path.source]) {\n        this.reverse[route.path.source] = [];\n    }\n\n    if (this.reverse[route.path.source].indexOf(route.method) === -1) {\n        this.reverse[route.path.source].push(route.method);\n    }\n\n    this.mounts[route.name] = route;\n\n    this.emit('mount',\n        route.method,\n        route.path,\n        route.types,\n        route.versions);\n\n    return (route.name);\n};\n\n\n/**\n * unmounts a route.\n * @public\n * @function unmount\n * @param    {String} name the route name\n * @returns  {String}      the name of the deleted route.\n */\nRouter.prototype.unmount = function unmount(name) {\n    var route = this.mounts[name];\n\n    if (!route) {\n        this.log.warn('router.unmount(%s): route does not exist', name);\n        return (false);\n    }\n\n    var reverse = this.reverse[route.path.source];\n    var routes = this.routes[route.method];\n    this.routes[route.method] = routes.filter(function (r) {\n        return (r.name !== route.name);\n    });\n\n    this.reverse[route.path.source] = reverse.filter(function (r) {\n        return (r !== route.method);\n    });\n\n    if (this.reverse[route.path.source].length === 0) {\n        delete this.reverse[route.path.source];\n    }\n\n    delete this.mounts[name];\n\n    return (name);\n};\n\n\n/**\n * get a route from the router.\n * @public\n * @function get\n * @param    {String}    name the name of the route to retrieve\n * @param    {Object}    req  the request object\n * @param    {Function}  cb   callback function\n * @returns  {undefined}\n */\nRouter.prototype.get = function get(name, req, cb) {\n    var params;\n    var route = false;\n    var routes = this.routes[req.method] || [];\n\n    var routeName = name.replace(/\\W/g, '').toLowerCase();\n\n    for (var i = 0; i < routes.length; i++) {\n        if (routes[i].name === routeName) {\n            route = routes[i];\n\n            try {\n                params = matchURL(route.path, req);\n            } catch (e) {\n                // if we couldn't match the URL, log it out.\n                console.log(e);\n            }\n            break;\n        }\n    }\n\n    if (route) {\n        cb(null, route, params || {});\n    } else {\n        cb(new InternalError());\n    }\n};\n\n\n/**\n * find a route from inside the router, handles versioned routes.\n * @public\n * @function find\n * @param    {Object}   req      the request object\n * @param    {Object}   res      the response object\n * @param    {Function} callback callback function\n * @returns  {undefined}\n */\nRouter.prototype.find = function find(req, res, callback) {\n    var candidates = [];\n    var ct = req.headers['content-type'] || DEF_CT;\n    var cacheKey = req.method + req.url + req.version() + ct;\n    var cacheVal;\n    var neg;\n    var params;\n    var r;\n    var reverse;\n    var routes = this.routes[req.method] || [];\n    var typed;\n    var versioned;\n    var maxV;\n\n    if ((cacheVal = this.cache.get(cacheKey))) {\n        res.methods = cacheVal.methods.slice();\n        req._matchedVersion = cacheVal.matchedVersion;\n        callback(null, cacheVal, shallowCopy(cacheVal.params));\n        return;\n    }\n\n    for (var i = 0; i < routes.length; i++) {\n        try {\n            params = matchURL(routes[i].path, req);\n        } catch (e) {\n            this.log.trace({err: e}, 'error parsing URL');\n            callback(new BadRequestError(e.message));\n            return;\n        }\n\n        if (params === false) {\n            continue;\n        }\n\n        reverse = this.reverse[routes[i].path.source];\n\n        if (routes[i].types.length && req.isUpload()) {\n            candidates.push({\n                p: params,\n                r: routes[i]\n            });\n            typed = true;\n            continue;\n        }\n\n        // GH-283: we want to find the latest version for a given route,\n        // not the first one.  However, if neither the client nor\n        // server specified any version, we're done, because neither\n        // cared\n        if (routes[i].versions.length === 0 && req.version() === '*') {\n            r = routes[i];\n            break;\n        }\n\n        if (routes[i].versions.length > 0) {\n            candidates.push({\n                p: params,\n                r: routes[i]\n            });\n            versioned = true;\n        }\n    }\n\n    if (!r) {\n        // If upload and typed\n        if (typed) {\n            var _t = ct.split(/\\s*,\\s*/);\n            candidates = candidates.filter(function (c) {\n                neg = new Negotiator({\n                    headers: {\n                        accept: c.r.types.join(', ')\n                    }\n                });\n                var tmp = neg.preferredMediaType(_t);\n                return (tmp && tmp.length);\n            });\n\n            // Pick the first one in case not versioned\n            if (candidates.length) {\n                r = candidates[0].r;\n                params = candidates[0].p;\n            }\n        }\n\n        if (versioned) {\n            candidates.forEach(function (c) {\n                var k = c.r.versions;\n                var v = semver.maxSatisfying(k, req.version());\n\n                if (v) {\n                    if (!r || semver.gt(v, maxV)) {\n                        r = c.r;\n                        params = c.p;\n                        maxV = v;\n                    }\n                }\n            });\n        }\n    }\n\n    // In order, we check if the route exists, in which case, we're good.\n    // Otherwise we look to see if ver was set to false; that would tell us\n    // we indeed did find a matching route (method+url), but the version\n    // field didn't line up, so we return bad version.  If no route and no\n    // version, we now need to go walk the reverse map and look at whether\n    // we should return 405 or 404.  If it was an OPTIONS request, we need\n    // to handle this having been a preflight request.\n    if (params && r) {\n        cacheVal = {\n            methods: reverse,\n            name: r.name,\n            params: params,\n            spec: r.spec\n        };\n\n        if (versioned) {\n            req._matchedVersion = maxV;\n            cacheVal.matchedVersion = maxV;\n        }\n\n        this.cache.set(cacheKey, cacheVal);\n        res.methods = reverse.slice();\n        callback(null, cacheVal, shallowCopy(params));\n        return;\n    }\n\n    if (typed) {\n        callback(new UnsupportedMediaTypeError(ct));\n        return;\n    }\n\n    if (versioned) {\n        callback(new InvalidVersionError('%s is not supported by %s %s',\n            req.version() || '?',\n            req.method,\n            req.path()));\n        return;\n    }\n\n    //Checks if header is in cors.ALLOWED_HEADERS\n    function inAllowedHeaders(header) {\n        header = header.toLowerCase();\n        return (cors.ALLOW_HEADERS.indexOf(header) !== -1);\n    }\n\n    // This is a very generic preflight handler - it does\n    // not handle requiring authentication, nor does it do\n    // any special checking for extra user headers. The\n    // user will need to defined their own .opts handler to\n    // do that\n    function preflight(methods) {\n        var headers = req.headers['access-control-request-headers'];\n        var method = req.headers['access-control-request-method'];\n        var origin = req.headers.origin;\n\n        if (req.method !== 'OPTIONS' || !origin || !method ||\n            methods.indexOf(method) === -1) {\n            return (false);\n        }\n\n        // Last, check request-headers\n        var ok = !headers || headers.split(/\\s*,\\s*/).every(inAllowedHeaders);\n\n        if (!ok) {\n            return (false);\n        }\n\n        // Verify the incoming origin against the whitelist. Pass the origin\n        // through if there is a match.\n        if (cors.matchOrigin(req, cors.origins)) {\n            res.setHeader('Access-Control-Allow-Origin', origin);\n\n            if (cors.credentials) {\n                res.setHeader('Access-Control-Allow-Credentials', 'true');\n            }\n        } else {\n            res.setHeader('Access-Control-Allow-Origin', '*');\n        }\n        res.setHeader('Access-Control-Allow-Methods',\n            methods.join(', '));\n        res.setHeader('Access-Control-Allow-Headers',\n            cors.ALLOW_HEADERS.join(', '));\n        res.setHeader('Access-Control-Max-Age', 3600);\n\n        return (true);\n    }\n\n    // Check for 405 instead of 404\n    var j;\n    var urls = Object.keys(this.reverse);\n\n    for (j = 0; j < urls.length; j++) {\n        if (matchURL(new RegExp(urls[j]), req)) {\n            res.methods = this.reverse[urls[j]].slice();\n            res.setHeader('Allow', res.methods.join(', '));\n\n            if (preflight(res.methods)) {\n                callback(null, {name: 'preflight'});\n                return;\n            }\n            var err = new MethodNotAllowedError('%s is not allowed',\n                req.method);\n            callback(err);\n            return;\n        }\n    }\n\n    // clean up the url in case of potential xss\n    // https://github.com/restify/node-restify/issues/1018\n    var cleanedUrl = url.parse(req.url).pathname;\n    callback(new ResourceNotFoundError(\n        '%s does not exist', cleanedUrl\n    ));\n};\n\n\n/**\n * toString() serialization.\n * @public\n * @function toString\n * @returns  {String}\n */\nRouter.prototype.toString = function toString() {\n    var self = this;\n    var str = this.name + ':\\n';\n\n    Object.keys(this.routes).forEach(function (k) {\n        var routes = self.routes[k].map(function (r) {\n            return (r.name);\n        });\n\n        str += '\\t\\t' + k + ': [' + routes.join(', ') + ']\\n';\n    });\n\n    return (str);\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/server.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar domain = require('domain');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\nvar once = require('once');\nvar spdy = require('spdy');\nvar uuid = require('node-uuid');\n\nvar dtrace = require('./dtrace');\nvar errors = require('./errors');\nvar formatters = require('./formatters');\nvar shallowCopy = require('./utils').shallowCopy;\nvar upgrade = require('./upgrade');\n\nvar semver = require('semver');\nvar maxSatisfying = semver.maxSatisfying;\n\n// Ensure these are loaded\nrequire('./request');\nrequire('./response');\n\n\n///--- Globals\n\nvar sprintf = util.format;\n\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\n\nvar PROXY_EVENTS = [\n    'clientError',\n    'close',\n    'connection',\n    'error',\n    'listening',\n    'secureConnection'\n];\n\n\n///--- Helpers\n\n/**\n * helper function to help verify and flatten an array of arrays.\n * takes an arguments object and an index frmo which to slice, then\n * merges that into a single array.\n * @private\n * @function argumentsToChain\n * @throws   {TypeError}\n * @param    {Object} args  pass through of funcs from server.[method]\n * @param    {Number} start index of args at which to start working with\n * @returns  {Array}\n */\nfunction argumentsToChain(args, start) {\n    assert.ok(args);\n\n    args = Array.prototype.slice.call(args, start);\n\n    if (args.length < 0) {\n        throw new TypeError('handler (function) required');\n    }\n\n    var chain = [];\n\n    function process(handlers) {\n        for (var i = 0; i < handlers.length; i++) {\n            if (Array.isArray(handlers[i])) {\n                process(handlers[i], 0);\n            } else {\n                assert.func(handlers[i], 'handler');\n                chain.push(handlers[i]);\n            }\n        }\n\n        return (chain);\n    }\n\n    return (process(args));\n}\n\n/**\n * merge optional formatters with the default formatters to create a single\n * formatters object. the passed in optional formatters object looks like:\n * formatters: {\n *   'application/foo': function formatFoo(req, res, body) {...}\n * }\n * @private\n * @function mergeFormatters\n * @param    {Object} fmt user specified formatters object\n * @returns  {Object}\n */\n\nfunction mergeFormatters(fmt) {\n    var arr = [];\n    var obj = {};\n\n    function addFormatter(src, k) {\n        assert.func(src[k], 'formatter');\n\n        var q = 1.0; // RFC 2616 sec14 - The default value is q=1\n        var t = k;\n\n        if (k.indexOf(';') !== -1) {\n            var tmp = k.split(/\\s*;\\s*/);\n            t = tmp[0];\n\n            if (tmp[1].indexOf('q=') !== -1) {\n                q = parseFloat(tmp[1].split('=')[1]);\n            }\n        }\n\n        if (k.indexOf('/') === -1) {\n            k = mime.lookup(k);\n        }\n\n        obj[t] = src[k];\n        arr.push({\n            q: q,\n            t: t\n        });\n    }\n\n    Object.keys(formatters).forEach(addFormatter.bind(this, formatters));\n    Object.keys(fmt || {}).forEach(addFormatter.bind(this, fmt || {}));\n\n    arr = arr.sort(function (a, b) {\n        return (b.q - a.q);\n    }).map(function (a) {\n            return (a.t);\n        });\n\n    return ({\n        formatters: obj,\n        acceptable: arr\n    });\n}\n\n\n/**\n * attaches ifError function attached to the `next` function in handler chain.\n * uses a closure to maintain ref to next.\n * @private\n * @function ifError\n * @param    {Function} n the next function\n * @returns  {Function}\n */\nfunction ifError(n) {\n    /**\n     * @throws   will throw if an error is passed in.\n     * @private\n     * @function _ifError\n     * @param    {Object} err an error object\n     * @returns  {undefined}\n     */\n    function _ifError(err) {\n        if (err) {\n            err._restify_next = n;\n            throw err;\n        }\n    }\n\n    return (_ifError);\n}\n\n\n/**\n * when an error occurrs, this is used to emit an error to consumers\n * via EventEmitter.\n * @private\n * @function emitRouteError\n * @param    {Object} server the server object\n * @param    {Object} req    the request object\n * @param    {Object} res    the response object\n * @param    {Object} err    an error object\n * @returns  {undefined}\n */\nfunction emitRouteError(server, req, res, err) {\n    var name;\n\n    if (err.name === 'ResourceNotFoundError') {\n        name = 'NotFound';\n    } else if (err.name === 'InvalidVersionError') {\n        name = 'VersionNotAllowed';\n    } else {\n        name = err.name.replace(/Error$/, '');\n    }\n\n    req.log.trace({name: name, err: err}, 'entering emitRouteError');\n\n    if (server.listeners(name).length > 0) {\n        server.emit(name, req, res, err, once(function () {\n            server.emit('after', req, res, null);\n        }));\n    } else {\n        res.send(err);\n        server.emit('after', req, res, null);\n    }\n}\n\n\n/**\n * returns true if an error generated is for an options request.\n * @private\n * @function optionsError\n * @param    {Object}     err an error object\n * @param    {Object}     req the request object\n * @param    {Object}     res the response object\n * @returns  {Boolean}\n */\nfunction optionsError(err, req, res) {\n    var code = err.statusCode;\n    var ok = false;\n\n    if (code === 404 && req.method === 'OPTIONS' && req.url === '*') {\n        res.send(200);\n        ok = true;\n    }\n\n    return (ok);\n}\n\n\n///--- API\n\n/**\n * Creates a new Server.\n * @public\n * @class\n * @param {Object} options an options object\n */\nfunction Server(options) {\n    assert.object(options, 'options');\n    assert.object(options.log, 'options.log');\n    assert.object(options.router, 'options.router');\n\n    var self = this;\n\n    EventEmitter.call(this);\n\n    this.before = [];\n    this.chain = [];\n    this.log = options.log;\n    this.name = options.name || 'restify';\n    this.router = options.router;\n    this.routes = {};\n    this.secure = false;\n    this.versions = options.versions || options.version || [];\n    this.socketio = options.socketio || false;\n\n    var fmt = mergeFormatters(options.formatters);\n    this.acceptable = fmt.acceptable;\n    this.formatters = fmt.formatters;\n\n    if (options.hasOwnProperty('handleUncaughtExceptions')) {\n        this.handleUncaughtExceptions = options.handleUncaughtExceptions;\n    } else {\n        this.handleUncaughtExceptions = true;\n    }\n\n    if (options.spdy) {\n        this.spdy = true;\n        this.server = spdy.createServer(options.spdy);\n    } else if ((options.cert || options.certificate) && options.key) {\n        this.ca = options.ca;\n        this.certificate = options.certificate || options.cert;\n        this.key = options.key;\n        this.passphrase = options.passphrase || null;\n        this.secure = true;\n\n        this.server = https.createServer({\n            ca: self.ca,\n            cert: self.certificate,\n            key: self.key,\n            passphrase: self.passphrase,\n            rejectUnauthorized: options.rejectUnauthorized,\n            requestCert: options.requestCert,\n            ciphers: options.ciphers\n        });\n    } else if (options.httpsServerOptions) {\n        this.server = https.createServer(options.httpsServerOptions);\n    } else {\n        this.server = http.createServer();\n    }\n\n    this.router.on('mount', this.emit.bind(this, 'mount'));\n\n    if (!options.handleUpgrades && PROXY_EVENTS.indexOf('upgrade') === -1) {\n        PROXY_EVENTS.push('upgrade');\n    }\n    PROXY_EVENTS.forEach(function (e) {\n        self.server.on(e, self.emit.bind(self, e));\n    });\n\n    // Now the things we can't blindly proxy\n    this.server.on('checkContinue', function onCheckContinue(req, res) {\n        if (self.listeners('checkContinue').length > 0) {\n            self.emit('checkContinue', req, res);\n            return;\n        }\n\n        if (!options.noWriteContinue) {\n            res.writeContinue();\n        }\n\n        self._setupRequest(req, res);\n        self._handle(req, res, true);\n    });\n\n    if (options.handleUpgrades) {\n        this.server.on('upgrade', function onUpgrade(req, socket, head) {\n            req._upgradeRequest = true;\n            var res = upgrade.createResponse(req, socket, head);\n            self._setupRequest(req, res);\n            self._handle(req, res);\n        });\n    }\n\n    this.server.on('request', function onRequest(req, res) {\n        self.emit('request', req, res);\n\n        if (options.socketio && (/^\\/socket\\.io.*/).test(req.url)) {\n            return;\n        }\n\n        self._setupRequest(req, res);\n        self._handle(req, res);\n    });\n\n    this.__defineGetter__('maxHeadersCount', function () {\n        return (self.server.maxHeadersCount);\n    });\n\n    this.__defineSetter__('maxHeadersCount', function (c) {\n        self.server.maxHeadersCount = c;\n        return (c);\n    });\n\n    this.__defineGetter__('url', function () {\n        if (self.socketPath) {\n            return ('http://' + self.socketPath);\n        }\n\n        var addr = self.address();\n        var str = '';\n\n        if (self.spdy) {\n            str += 'spdy://';\n        } else if (self.secure) {\n            str += 'https://';\n        } else {\n            str += 'http://';\n        }\n\n        if (addr) {\n            str += addr.family === 'IPv6' ?\n                '[' + addr.address + ']' : addr.address;\n            str += ':';\n            str += addr.port;\n        } else {\n            str += '169.254.0.1:0000';\n        }\n\n        return (str);\n    });\n}\nutil.inherits(Server, EventEmitter);\n\nmodule.exports = Server;\n\n\n/**\n * Returns the server address. Wraps node's address().\n * @public\n * @function address\n * @returns  {String}\n */\nServer.prototype.address = function address() {\n    return (this.server.address());\n};\n\n\n/**\n * Gets the server up and listening. Wraps node's listen().\n *\n * You can call like:\n *  server.listen(80)\n *  server.listen(80, '127.0.0.1')\n *  server.listen('/tmp/server.sock')\n *\n * @public\n * @function listen\n * @throws   {TypeError}\n * @param    {Function}  callback optionally get notified when listening.\n * @returns  {undefined}\n */\nServer.prototype.listen = function listen() {\n    var args = Array.prototype.slice.call(arguments);\n    return (this.server.listen.apply(this.server, args));\n};\n\n\n/**\n * Shuts down this server, and invokes callback (optionally) when done.\n * Wraps node's close().\n * @public\n * @function close\n * @param    {Function}  callback optional callback to invoke when done.\n * @returns  {undefined}\n */\nServer.prototype.close = function close(callback) {\n    if (callback) {\n        assert.func(callback, 'callback');\n    }\n\n    this.server.once('close', function onClose() {\n        return (callback ? callback() : false);\n    });\n\n    return (this.server.close());\n};\n\n\n// Register all the routing methods\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @function del, get, head, opts, post, put, patch\n * @param   {String | Object} opts if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n[\n    'del',\n    'get',\n    'head',\n    'opts',\n    'post',\n    'put',\n    'patch'\n].forEach(function (method) {\n        Server.prototype[method] = function (opts) {\n            if (opts instanceof RegExp || typeof (opts) === 'string') {\n                opts = {\n                    path: opts\n                };\n            } else if (typeof (opts) === 'object') {\n                opts = shallowCopy(opts);\n            } else {\n                throw new TypeError('path (string) required');\n            }\n\n            if (arguments.length < 2) {\n                throw new TypeError('handler (function) required');\n            }\n\n            var chain = [];\n            var route;\n            var self = this;\n\n            function addHandler(h) {\n                assert.func(h, 'handler');\n\n                chain.push(h);\n            }\n\n            if (method === 'del') {\n                method = 'DELETE';\n            }\n\n            if (method === 'opts') {\n                method = 'OPTIONS';\n            }\n            opts.method = method.toUpperCase();\n            opts.versions = opts.versions || opts.version || self.versions;\n\n            if (!Array.isArray(opts.versions)) {\n                opts.versions = [opts.versions];\n            }\n\n            if (!opts.name) {\n                opts.name = method + '-' + (opts.path || opts.url);\n\n                if (opts.versions.length > 0) {\n                    opts.name += '-' + opts.versions.join('--');\n                }\n\n                opts.name = opts.name.replace(/\\W/g, '').toLowerCase();\n\n                if (this.router.mounts[opts.name]) { // GH-401\n                    opts.name += uuid.v4().substr(0, 7);\n                }\n            } else {\n                opts.name = opts.name.replace(/\\W/g, '').toLowerCase();\n            }\n\n\n            if (!(route = this.router.mount(opts))) {\n                return (false);\n            }\n\n            this.chain.forEach(addHandler);\n            argumentsToChain(arguments, 1).forEach(addHandler);\n            this.routes[route] = chain;\n\n            return (route);\n        };\n    });\n\n\n/**\n * Minimal port of the functionality offered by Express.js Route Param\n * Pre-conditions\n * @link http://expressjs.com/guide.html#route-param%20pre-conditions\n *\n * This basically piggy-backs on the `server.use` method. It attaches a\n * new middleware function that only fires if the specified parameter exists\n * in req.params\n *\n * Exposes an API:\n *   server.param(\"user\", function (req, res, next) {\n *     // load the user's information here, always making sure to call next()\n *   });\n *\n * @public\n * @function param\n * @param    {String}   name The name of the URL param to respond to\n * @param    {Function} fn   The middleware function to execute\n * @returns  {Object}        returns self\n */\nServer.prototype.param = function param(name, fn) {\n    this.use(function _param(req, res, next) {\n        if (req.params && req.params[name]) {\n            fn.call(this, req, res, next, req.params[name], name);\n        } else {\n            next();\n        }\n    });\n\n    return (this);\n};\n\n\n/**\n * Piggy-backs on the `server.use` method. It attaches a new middleware\n * function that only fires if the specified version matchtes the request.\n *\n * Note that if the client does not request a specific version, the middleware\n * function always fires. If you don't want this set a default version with a\n * pre handler on requests where the client omits one.\n *\n * Exposes an API:\n *   server.versionedUse(\"version\", function (req, res, next, ver) {\n *     // do stuff that only applies to routes of this API version\n *   });\n *\n * @public\n * @function versionedUse\n * @param    {String|Array} versions the version(s) the URL to respond to\n * @param    {Function}     fn       the middleware function to execute, the\n *                                   fourth parameter will be the selected\n *                                   version\n * @returns  {undefined}\n */\nServer.prototype.versionedUse = function versionedUse(versions, fn) {\n    if (!Array.isArray(versions)) {\n        versions = [versions];\n    }\n    assert.arrayOfString(versions, 'versions');\n\n    versions.forEach(function (v) {\n        if (!semver.valid(v)) {\n            throw new TypeError('%s is not a valid semver', v);\n        }\n    });\n\n    this.use(function _versionedUse(req, res, next) {\n        var ver;\n\n        if (req.version() === '*' ||\n            (ver = maxSatisfying(versions,\n                req.version()) || false)) {\n            fn.call(this, req, res, next, ver);\n        } else {\n            next();\n        }\n    });\n\n    return (this);\n};\n\n\n/**\n * Removes a route from the server.\n * You pass in the route 'blob' you got from a mount call.\n * @public\n * @function rm\n * @throws   {TypeError} on bad input.\n * @param    {String}    route the route name.\n * @returns  {Boolean}         true if route was removed, false if not.\n */\nServer.prototype.rm = function rm(route) {\n    var r = this.router.unmount(route);\n\n    if (r && this.routes[r]) {\n        delete this.routes[r];\n    }\n\n    return (r);\n};\n\n\n/**\n * Installs a list of handlers to run _before_ the \"normal\" handlers of all\n * routes.\n *\n * You can pass in any combination of functions or array of functions.\n * @public\n * @function use\n * @returns {Object} returns self\n */\nServer.prototype.use = function use() {\n    var self = this;\n\n    (argumentsToChain(arguments) || []).forEach(function (h) {\n        self.chain.push(h);\n    });\n\n    return (this);\n};\n\n\n/**\n * Gives you hooks to run _before_ any routes are located.  This gives you\n * a chance to intercept the request and change headers, etc., that routing\n * depends on.  Note that req.params will _not_ be set yet.\n * @public\n * @function pre\n * @returns {Object} returns self\n */\nServer.prototype.pre = function pre() {\n    var self = this;\n\n    argumentsToChain(arguments).forEach(function (h) {\n        self.before.push(h);\n    });\n\n    return (this);\n};\n\n\n/**\n * toString() the server for easy reading/output.\n * @public\n * @function toString\n * @returns  {String}\n */\nServer.prototype.toString = function toString() {\n    var LINE_FMT = '\\t%s: %s\\n';\n    var SUB_LINE_FMT = '\\t\\t%s: %s\\n';\n    var self = this;\n    var str = '';\n\n    function handlersToString(arr) {\n        var s = '[' + arr.map(function (b) {\n            return (b.name || 'function');\n        }).join(', ') + ']';\n\n        return (s);\n    }\n\n    str += sprintf(LINE_FMT, 'Accepts', this.acceptable.join(', '));\n    str += sprintf(LINE_FMT, 'Name', this.name);\n    str += sprintf(LINE_FMT, 'Pre', handlersToString(this.before));\n    str += sprintf(LINE_FMT, 'Router', this.router.toString());\n    str += sprintf(LINE_FMT, 'Routes', '');\n    Object.keys(this.routes).forEach(function (k) {\n        var handlers = handlersToString(self.routes[k]);\n        str += sprintf(SUB_LINE_FMT, k, handlers);\n    });\n    str += sprintf(LINE_FMT, 'Secure', this.secure);\n    str += sprintf(LINE_FMT, 'Url', this.url);\n    str += sprintf(LINE_FMT, 'Version', Array.isArray(this.versions) ?\n                   this.versions.join() :\n                   this.versions);\n\n    return (str);\n};\n\n\n///--- Private methods\n\n/**\n * upon receivng a request, route the request, then run the chain of handlers.\n * @private\n * @function _handle\n * @param    {Object} req the request object\n * @param    {Object} res the response object\n * @returns  {undefined}\n */\nServer.prototype._handle = function _handle(req, res) {\n    var self = this;\n\n    function routeAndRun() {\n        self._route(req, res, function (route, context) {\n            req.context = req.params = context;\n            req.route = route.spec;\n\n            var r = route ? route.name : null;\n            var chain = self.routes[r];\n\n            self._run(req, res, route, chain, function done(e) {\n                self.emit('after', req, res, route, e);\n            });\n        });\n    }\n\n    if (this.before.length > 0) {\n        this._run(req, res, null, this.before, function (err) {\n            if (!err) {\n                routeAndRun();\n            }\n        });\n    } else {\n        routeAndRun();\n    }\n};\n\n\n/**\n * look into the router, find the route object that should match this request.\n * @private\n * @function _route\n * @param    {Object}    req    the request object\n * @param    {Object}    res    the response object\n * @param    {String}    [name] name of the route\n * @param    {Function}  cb     callback function\n * @returns  {undefined}\n */\nServer.prototype._route = function _route(req, res, name, cb) {\n    var self = this;\n\n    if (typeof (name) === 'function') {\n        cb = name;\n        name = null;\n\n        this.router.find(req, res, function onRoute(err, route, ctx) {\n            var r = route ? route.name : null;\n\n            if (err) {\n                if (optionsError(err, req, res)) {\n                    self.emit('after', req, res, err);\n                } else {\n                    emitRouteError(self, req, res, err);\n                }\n            } else if (r === 'preflight') {\n                res.writeHead(200);\n                res.end();\n                self.emit('after', req, res, null);\n            } else if (!r || !self.routes[r]) {\n                err = new ResourceNotFoundError(req.path());\n                emitRouteError(self, res, res, err);\n            } else {\n                cb(route, ctx);\n            }\n        });\n    } else {\n        this.router.get(name, req, function (err, route, ctx) {\n            if (err) {\n                emitRouteError(self, req, res, err);\n            } else {\n                cb(route, ctx);\n            }\n        });\n    }\n};\n\n\n/*\n * The goofy checks in next() are to make sure we fire the DTrace\n * probes after an error might have been sent, as in a handler\n * return next(new Error) is basically shorthand for sending an\n * error via res.send(), so we do that before firing the dtrace\n * probe (namely so the status codes get updated in the\n * response).\n *\n * Callers can stop the chain from proceding if they do\n * return next(false); This is useful for non-errors, but where\n * a response was sent and you don't want the chain to keep\n * going.\n *\n * @private\n * @function _run\n * @param    {Object}    req   the request object\n * @param    {Object}    res   the response object\n * @param    {Object}    route the route object\n * @param    {Array}     chain array of handler functions\n * @param    {Function}  cb    callback function\n * @returns  {undefined}\n */\nServer.prototype._run = function _run(req, res, route, chain, cb) {\n    var d;\n    var i = -1;\n    var id = dtrace.nextId();\n    req._dtraceId = id;\n\n    if (!req._anonFuncCount) {\n        // Counter used to keep track of anonymous functions. Used when a\n        // handler function is anonymous. This ensures we're using a\n        // monotonically increasing int for anonymous handlers through out the\n        // the lifetime of this request\n        req._anonFuncCount = 0;\n    }\n    var log = this.log;\n    var self = this;\n    var handlerName = null;\n    var errName;\n    var emittedError = false;\n\n    if (cb) {\n        cb = once(cb);\n    }\n\n    function next(arg) {\n        var done = false;\n\n        if (arg) {\n            if (arg instanceof Error) {\n                errName = arg.name.replace(/Error$/, '');\n                log.trace({err: arg, errName: errName}, 'next(err=%s)',\n                    (arg.name || 'Error'));\n\n                if (self.listeners(errName).length > 0) {\n                    self.emit(errName, req, res, arg, once(function () {\n                        res.send(arg);\n                        return (cb ? cb(arg) : true);\n                    }));\n                    emittedError = true;\n                } else {\n                    res.send(arg);\n                }\n                done = true;\n            } else if (typeof (arg) === 'string') { // GH-193, allow redirect\n                if (req._rstfy_chained_route) {\n                    var _e = new errors.InternalError();\n                    log.error({\n                        err: _e\n                    }, 'Multiple next(\"chain\") calls not ' +\n                        'supported');\n                    res.send(_e);\n                    return (false);\n                }\n\n                // Stop running the rest of this route since we're redirecting\n                return self._route(req, res, arg, function (r, ctx) {\n                    req.context = req.params = ctx;\n                    req.route = r.spec;\n\n                    var _c = chain.slice(0, i + 1);\n\n                    function _uniq(fn) {\n                        return (_c.indexOf(fn) === -1);\n                    }\n\n                    var _routes = self.routes[r.name] || [];\n                    var _chain = _routes.filter(_uniq);\n\n                    req._rstfy_chained_route = true;\n\n                    // Need to fire DTrace done for previous handler here too.\n                    if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {\n                        req.endHandlerTimer(handlerName);\n                    }\n                    self._run(req, res, r, _chain, cb);\n                });\n            }\n        }\n\n        if (arg === false) {\n            done = true;\n        }\n\n        // Fire DTrace done for the previous handler.\n        if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {\n            req.endHandlerTimer(handlerName);\n        }\n\n        // Run the next handler up\n        if (!done && chain[++i]) {\n            if (chain[i]._skip) {\n                return (next());\n            }\n\n            if (log.trace()) {\n                log.trace('running %s', chain[i].name || '?');\n            }\n\n            req._currentRoute = (route !== null ? route.name : 'pre');\n            handlerName = (chain[i].name ||\n                           ('handler-' + req._anonFuncCount++));\n            req._currentHandler = handlerName;\n            req.startHandlerTimer(handlerName);\n\n            var n = once(next);\n            n.ifError = ifError(n);\n            return (chain[i].call(self, req, res, n));\n        }\n\n        dtrace._rstfy_probes['route-done'].fire(function () {\n            return ([\n                self.name,\n                route !== null ? route.name : 'pre',\n                id,\n                res.statusCode || 200,\n                res.headers()\n            ]);\n        });\n\n        if (route === null) {\n            self.emit('preDone', req, res);\n        } else {\n            self.emit('done', req, res, route);\n        }\n\n        // Don't return cb here if we emit an error since we will cb after the\n        // handler fires.\n        if (!emittedError) {\n            return (cb ? cb(arg) : true);\n        } else {\n            return (true);\n        }\n    }\n\n    var n1 = once(next);\n    n1.ifError = ifError(n1);\n\n    dtrace._rstfy_probes['route-start'].fire(function () {\n        return ([\n            self.name,\n            route !== null ? route.name : 'pre',\n            id,\n            req.method,\n            req.href(),\n            req.headers\n        ]);\n    });\n\n    if (!self.handleUncaughtExceptions) {\n        n1();\n        return;\n    }\n\n    // Add the uncaughtException error handler.\n    d = domain.create();\n    d.add(req);\n    d.add(res);\n    d.on('error', function onError(err) {\n        if (err._restify_next) {\n            err._restify_next(err);\n        } else {\n            log.trace({err: err}, 'uncaughtException');\n            self.emit('uncaughtException', req, res, route, err);\n        }\n    });\n    d.run(n1);\n};\n\n\n/**\n * set up the request by before routing and executing handler chain.\n * @private\n * @function _setupRequest\n * @param    {Object}    req the request object\n * @param    {Object}    res the response object\n * @returns  {undefined}\n */\nServer.prototype._setupRequest = function _setupRequest(req, res) {\n    req.log = res.log = this.log;\n    req._time = res._time = Date.now();\n    req.serverName = this.name;\n\n    res.acceptable = this.acceptable;\n    res.formatters = this.formatters;\n    res.req = req;\n    res.serverName = this.name;\n    res.version = this.router.versions[this.router.versions.length - 1];\n};\n","/home/travis/build/npmtest/node-npmtest-restify/node_modules/restify/lib/upgrade.js":"// Copyright (c) 2013, Joyent, Inc. All rights reserved.\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar assert = require('assert-plus');\n\n/**\n * an custom error for capturing an invalid upgrade state.\n * @public\n * @class\n * @param {String} msg an error message\n */\nfunction InvalidUpgradeStateError(msg) {\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, InvalidUpgradeStateError);\n    }\n\n    this.message = msg;\n    this.name = 'InvalidUpgradeStateError';\n}\nutil.inherits(InvalidUpgradeStateError, Error);\n\n//\n// The Node HTTP Server will, if we handle the 'upgrade' event, swallow any\n// Request with the 'Connection: upgrade' header set.  While doing this it\n// detaches from the 'data' events on the Socket and passes the socket to\n// us, so that we may take over handling for the connection.\n//\n// Unfortunately, the API does not presently provide a http.ServerResponse\n// for us to use in the event that we do not wish to upgrade the connection.\n// This factory method provides a skeletal implementation of a\n// restify-compatible response that is sufficient to allow the existing\n// request handling path to work, while allowing us to perform _at most_ one\n// of either:\n//\n//   - Return a basic HTTP Response with a provided Status Code and\n//     close the socket.\n//   - Upgrade the connection and stop further processing.\n//\n// To determine if an upgrade is requested, a route handler would check for\n// the 'claimUpgrade' method on the Response.  The object this method\n// returns will have the 'socket' and 'head' Buffer emitted with the\n// 'upgrade' event by the http.Server.  If the upgrade is not possible, such\n// as when the HTTP head (or a full request) has already been sent by some\n// other handler, this method will throw.\n//\n\n/**\n * create a new upgraded response.\n * @public\n * @function createServerUpgradeResponse\n * @param    {Object} req    the request object\n * @param    {Object} socket the network socket\n * @param    {Object} head   a buffer, the first packet of the upgraded stream\n * @returns  {Object}        an upgraded reponses\n */\nfunction createServerUpgradeResponse(req, socket, head) {\n    return (new ServerUpgradeResponse(socket, head));\n}\n\n\n/**\n * upgrade the http response\n * @private\n * @class\n * @param   {Object}    socket the network socket\n * @param   {Object}    head   a buffer, the first packet of the upgraded stream\n * @returns {undefined}\n */\nfunction ServerUpgradeResponse(socket, head) {\n    assert.object(socket, 'socket');\n    assert.buffer(head, 'head');\n\n    EventEmitter.call(this);\n\n    this.sendDate = true;\n    this.statusCode = 400;\n\n    this._upgrade = {\n        socket: socket,\n        head: head\n    };\n\n    this._headWritten = false;\n    this._upgradeClaimed = false;\n}\nutil.inherits(ServerUpgradeResponse, EventEmitter);\n\n\n/**\n * a function generator for all programatically attaching methods on to\n * the ServerUpgradeResponse class.\n * @private\n * @function notImplemented\n * @param    {Object}   method an object containing configuration\n * @returns  {Function}\n */\nfunction notImplemented(method) {\n    if (!method.throws) {\n        return function () {\n            return (method.returns);\n        };\n    } else {\n        return function () {\n            throw (new Error('Method ' + method.name + ' is not ' +\n                'implemented!'));\n        };\n    }\n}\n\nvar NOT_IMPLEMENTED = [\n    { name: 'writeContinue', throws: true },\n    { name: 'setHeader', throws: false, returns: null },\n    { name: 'getHeader', throws: false, returns: null },\n    { name: 'getHeaders', throws: false, returns: {} },\n    { name: 'removeHeader', throws: false, returns: null },\n    { name: 'addTrailer', throws: false, returns: null },\n    { name: 'cache', throws: false, returns: 'public' },\n    { name: 'format', throws: true },\n    { name: 'set', throws: false, returns: null },\n    { name: 'get', throws: false, returns: null },\n    { name: 'headers', throws: false, returns: {} },\n    { name: 'header', throws: false, returns: null },\n    { name: 'json', throws: false, returns: null },\n    { name: 'link', throws: false, returns: null }\n];\n\n// programatically add a bunch of methods to the ServerUpgradeResponse proto\nNOT_IMPLEMENTED.forEach(function (method) {\n    ServerUpgradeResponse.prototype[method.name] = notImplemented(method);\n});\n\n\n/**\n * internal implementation of writeHead\n * @private\n * @function _writeHeadImpl\n * @param   {Number} statusCode the http status code\n * @param   {String} reason     a message\n * @returns {undefined}\n */\nServerUpgradeResponse.prototype._writeHeadImpl =\n    function _writeHeadImpl(statusCode, reason) {\n        if (this._headWritten) {\n            return;\n        }\n        this._headWritten = true;\n\n        if (this._upgradeClaimed) {\n            throw new InvalidUpgradeStateError('Upgrade already claimed!');\n        }\n\n        var head = [\n            'HTTP/1.1 ' + statusCode + ' ' + reason,\n            'Connection: close'\n        ];\n\n        if (this.sendDate) {\n            head.push('Date: ' + new Date().toUTCString());\n        }\n\n        this._upgrade.socket.write(head.join('\\r\\n') + '\\r\\n');\n    };\n\n\n/**\n * set the status code of the response\n * @public\n * @function  status\n * @param     {Number} code the http status code\n * @returns   {undefined}\n */\nServerUpgradeResponse.prototype.status = function status(code) {\n    assert.number(code, 'code');\n    this.statusCode = code;\n    return (code);\n};\n\n\n/**\n * sends the response\n * @public\n * @function  send\n * @param     {Number}           code the http status code\n * @param     {Object | String}  body the response to send out\n * @returns   {undefined}\n */\nServerUpgradeResponse.prototype.send = function send(code, body) {\n    if (typeof (code) === 'number') {\n        this.statusCode = code;\n    } else {\n        body = code;\n    }\n\n    if (typeof (body) === 'object') {\n        if (typeof (body.statusCode) === 'number') {\n            this.statusCode = body.statusCode;\n        }\n\n        if (typeof (body.message) === 'string') {\n            this.statusReason = body.message;\n        }\n    }\n\n    return (this.end());\n};\n\n\n/**\n * end the response\n * @public\n * @function end\n * @returns  {Boolean} always returns true\n */\nServerUpgradeResponse.prototype.end = function end() {\n    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');\n    this._upgrade.socket.end('\\r\\n');\n    return (true);\n};\n\n\n/**\n * write to the response\n * @public\n * @function write\n * @returns  {Boolean} always returns true\n */\nServerUpgradeResponse.prototype.write = function write() {\n    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');\n    return (true);\n};\n\n\n/**\n * write to the head of the response\n * @public\n * @function writeHead\n * @param   {Number} statusCode the http status code\n * @param   {String} reason     a message\n * @returns {undefined}\n */\nServerUpgradeResponse.prototype.writeHead =\n    function writeHead(statusCode, reason) {\n        assert.number(statusCode, 'statusCode');\n        assert.optionalString(reason, 'reason');\n\n        this.statusCode = statusCode;\n\n        if (!reason) {\n            reason = 'Connection Not Upgraded';\n        }\n\n        if (this._headWritten) {\n            throw new Error('Head already written!');\n        }\n\n        return (this._writeHeadImpl(statusCode, reason));\n    };\n\n\n/**\n * attempt to upgrade\n * @public\n * @function claimUpgrade\n * @returns  {Object}     an object containing the socket and head\n */\nServerUpgradeResponse.prototype.claimUpgrade = function claimUpgrade() {\n    if (this._upgradeClaimed) {\n        throw new InvalidUpgradeStateError('Upgrade already claimed!');\n    }\n\n    if (this._headWritten) {\n        throw new InvalidUpgradeStateError('Upgrade already aborted!');\n    }\n\n    this._upgradeClaimed = true;\n\n    return (this._upgrade);\n};\n\n\nmodule.exports = {\n    createResponse: createServerUpgradeResponse,\n    InvalidUpgradeStateError: InvalidUpgradeStateError\n};\n\n"}