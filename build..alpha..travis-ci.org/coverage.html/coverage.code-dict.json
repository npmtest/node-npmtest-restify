{"/home/travis/build/npmtest/node-npmtest-restify/test.js":"/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/lib.npmtest_restify.js":"/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_restify = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_restify = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-restify && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_restify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_restify\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_restify.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_restify.rollup.js'] =\n            local.assetsDict['/assets.npmtest_restify.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_restify.__dirname +\n                    '/lib.npmtest_restify.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n//\n// Restify supports both a client and server API, and in the essence of not\n// loading the kitchen sink on clients, the exports here is chunked up into\n// client and server; note clients will have to opt in by setting the env\n// var \"RESTIFY_CLIENT_ONLY\", but if you're in that boat, it's not hard to do,\n// and enables much faster load times\n//\n\n'use strict';\n\nvar shallowCopy = require('./utils').shallowCopy;\n\n\n/**\n * creates an http request client. based on options passed in, will create one\n * of three existing clients: Http, String, or Json.\n * @public\n * @function createClient\n * @param    {Object} options      an options object\n * @param    {String} options.type 'http' | 'json' | 'string'\n * @returns  {HttpClient | JsonClient | StringClient}\n */\nfunction createClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    var assert = require('assert-plus');\n    var bunyan = require('./bunyan_helper');\n    var clients = require('./clients');\n\n    assert.object(options, 'options');\n\n    var client;\n    var opts = shallowCopy(options);\n    opts.agent = options.agent;\n    opts.name = opts.name || 'restify';\n    opts.type = opts.type || 'application/octet-stream';\n    opts.log = opts.log || bunyan.createLogger(opts.name);\n\n    switch (opts.type) {\n        case 'json':\n            client = new clients.JsonClient(opts);\n            break;\n\n        case 'string':\n            client = new clients.StringClient(opts);\n            break;\n\n        case 'http':\n        default:\n            client = new clients.HttpClient(opts);\n            break;\n    }\n\n    return (client);\n}\n\n\n/**\n * creates a json httpclient.\n * @public\n * @function createJsonClient\n * @param    {Object}     options an options object\n * @returns  {JsonClient}         a json client\n */\nfunction createJsonClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'json';\n    return (createClient(options));\n}\n\n\n/**\n * creates a string httpclient.\n * @public\n * @function createStringClient\n * @param    {Object}       options an options object\n * @returns  {StringClient}         a string client\n */\nfunction createStringClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'string';\n    return (createClient(options));\n}\n\n\n/**\n * creates a regular httpclient.\n * @public\n * @function createHttpClient\n * @param    {Object}     options an options object\n * @returns  {HttpClient}         an http client\n */\nfunction createHttpClient(options) {\n    if (typeof (options) === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    options = options ? shallowCopy(options) : {};\n    options.type = 'http';\n    return (createClient(options));\n}\n\n\n/**\n * creates a server.\n * @public\n * @function createServer\n * @param    {Object} options an options object\n * @returns  {Server}\n */\nfunction createServer(options) {\n    var bunyan = require('./bunyan_helper');\n    var InternalError = require('./errors').InternalError;\n    var Router = require('./router');\n    var Server = require('./server');\n\n    var opts = shallowCopy(options || {});\n    var server;\n\n    opts.name = opts.name || 'restify';\n    opts.log = opts.log || bunyan.createLogger(opts.name);\n    opts.router = opts.router || new Router(opts);\n\n    server = new Server(opts);\n\n    if (server.handleUncaughtExceptions) {\n        server.on('uncaughtException', function (req, res, route, e) {\n            if (this.listeners('uncaughtException').length > 1 ||\n                res.headersSent) {\n                return (false);\n            }\n\n            res.send(new InternalError(e, e.message || 'unexpected error'));\n            return (true);\n        });\n    }\n\n    return (server);\n}\n\n\n/**\n * Returns a string representation of a URL pattern , with its\n * parameters filled in by the passed hash.\n *\n * If a key is not found in the hash for a param, it is left alone.\n * @public\n * @function realizeUrl\n * @param   {String} pattern a url string\n * @param   {Object} params  a hash of parameter names to values for\n *                           substitution\n * @returns {String}\n */\nfunction realizeUrl(pattern, params) {\n    var p = pattern.replace(/\\/:([^/]+)/g, function (match, k) {\n        return (params.hasOwnProperty(k) ? '/' + params[k] : match);\n    });\n\n\n    return (require('./utils').sanitizePath(p));\n}\n\n\n///--- Exports\n\nmodule.exports = {\n    // Client API\n    createClient: createClient,\n    createJsonClient: createJsonClient,\n    createJSONClient: createJsonClient,\n    createStringClient: createStringClient,\n    createHttpClient: createHttpClient,\n    get HttpClient() {\n        return (require('./clients').HttpClient);\n    },\n    get JsonClient() {\n        return (require('./clients').JsonClient);\n    },\n    get StringClient() {\n        return (require('./clients').StringClient);\n    },\n\n    // Miscellaneous API\n    get bunyan() {\n        return (require('./bunyan_helper'));\n    },\n\n    errors: {}\n\n};\n\nvar errors = require('./errors');\nObject.keys(errors).forEach(function (k) {\n    module.exports.errors[k] = errors[k];\n    module.exports[k] = errors[k];\n});\n\nif (!process.env.RESTIFY_CLIENT_ONLY) {\n\n    module.exports.createServer = createServer;\n    module.exports.httpDate = require('./http_date');\n    module.exports.realizeUrl = realizeUrl;\n    module.exports.formatters = require('./formatters');\n    module.exports.plugins = {};\n    var plugins = require('./plugins');\n    Object.keys(plugins).forEach(function (k) {\n        module.exports.plugins[k] = plugins[k];\n        module.exports[k] = plugins[k];\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/utils.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n/**\n * Cleans up sloppy URL paths, like /foo////bar/// to /foo/bar.\n * @public\n * @method  sanitizePath\n * @param   {String} path the HTTP resource path.\n * @returns {String}      Cleaned up form of path.\n */\nfunction sanitizePath(path) {\n    assert.ok(path);\n\n    // Be nice like apache and strip out any //my//foo//bar///blah\n    path = path.replace(/\\/\\/+/g, '/');\n\n    // Kill a trailing '/'\n    if (path.lastIndexOf('/') === (path.length - 1) && path.length > 1) {\n        path = path.substr(0, path.length - 1);\n    }\n\n    return (path);\n}\n\n\n/**\n * Return a shallow copy of the given object;\n * @public\n * @method  shallowCopy\n * @param   {Object} obj the object to copy\n * @returns {Object}     the new copy of the object\n */\nfunction shallowCopy(obj) {\n    if (!obj) {\n        return (obj);\n    }\n    var copy = {};\n    Object.keys(obj).forEach(function (k) {\n        copy[k] = obj[k];\n    });\n    return (copy);\n}\n\n\n/**\n * Merges two query parameter objects. Merges to array\n * if the same key is encountered.\n * @public\n * @method  mergeQs\n * @param   {Object} obj1 first qs object\n * @param   {Object} obj2 second qs object\n * @returns {Object}      the merged object\n */\nfunction mergeQs(obj1, obj2) {\n\n    var merged = shallowCopy(obj1) || {};\n\n    // defend against null cause null is an object. yay js.\n    if (obj2 && typeof (obj2) === 'object') {\n        Object.keys(obj2).forEach(function (key) {\n            // if we already have this key and it isn't an array,\n            // make it one array of the same element.\n            if (merged.hasOwnProperty(key) && !(merged[key] instanceof Array)) {\n                merged[key] = [merged[key]];\n\n                // push the new value down\n                merged[key].push(obj2[key]);\n            } else {\n                // otherwise just set it\n                merged[key] = obj2[key];\n            }\n        });\n    }\n\n    return (merged);\n}\n\n\n///--- Exports\n\nmodule.exports = {\n    sanitizePath: sanitizePath,\n    shallowCopy: shallowCopy,\n    mergeQs: mergeQs\n};\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/errors/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar httpErrors = require('./http_error');\nvar restErrors = require('./rest_error');\n\n\nmodule.exports = {};\n\nObject.keys(httpErrors).forEach(function (k) {\n    module.exports[k] = httpErrors[k];\n});\n\n// Note some of the RestErrors overwrite plain HTTP errors.\nObject.keys(restErrors).forEach(function (k) {\n    module.exports[k] = restErrors[k];\n});\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/errors/http_error.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n// Because we are constructing error objects dynamically, we use an anonymous\n// function as the 'base constructor' then use arguments.callee to fill that in.\n// strict mode disallows agruments.callee, disable both of these rules.\n\n/* eslint-disable strict, no-caller */\n\nvar http = require('http');\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar WError = require('verror').WError;\n\n\n///--- Globals\n\nvar slice = Function.prototype.call.bind(Array.prototype.slice);\n\n\n///--- Helpers\n\n/**\n * used to programatically create http error code names, using the underlying\n * status codes names exposed via the http module.\n * @private\n * @function codeToErrorName\n * @param    {Number} code the http error code to dynamically create\n * @returns  {String}\n */\nfunction codeToErrorName(code) {\n    code = parseInt(code, 10);\n    var status = http.STATUS_CODES[code];\n\n    if (!status) {\n        return (false);\n    }\n\n\n    var pieces = status.split(/\\s+/);\n    var str = '';\n    pieces.forEach(function (s) {\n        str += s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();\n    });\n\n    str = str.replace(/\\W+/g, '');\n\n    if (!/\\w+Error$/.test(str)) {\n        str += 'Error';\n    }\n\n    return (str);\n}\n\n\n///--- Error Base class\n\n/**\n * HttpError class. inherits from WError.\n * @public\n * @class\n * @param {Object} options an options object\n */\nfunction HttpError(options) {\n    assert.object(options, 'options');\n\n    options.constructorOpt = options.constructorOpt || HttpError;\n    WError.apply(this, arguments);\n\n    var self = this;\n    var code = parseInt((options.statusCode || 500), 10);\n    this.statusCode = code;\n    this.body = options.body || {\n        code: codeToErrorName(code),\n        message: options.message || self.message\n    };\n    this.message = options.message || self.message;\n}\nutil.inherits(HttpError, WError);\n\n\n///--- Exports\n\nmodule.exports = {\n\n    HttpError: HttpError,\n\n    codeToHttpError: function codeToHttpError(code, message, body) {\n        var err;\n        var name = codeToErrorName(code);\n\n        if (!name) {\n            err = new HttpError({\n                statusCode: code,\n                message: message,\n                body: body\n            });\n            err.name = 'Http' + code + 'Error';\n        } else {\n            err = new module.exports[name]({\n                body: body,\n                message: message,\n                constructorOpt: codeToHttpError,\n                statusCode: code\n            });\n        }\n\n        return (err);\n    }\n\n};\n\n\n// Export all the 4xx and 5xx HTTP Status codes as Errors\nvar codes = Object.keys(http.STATUS_CODES);\n\ncodes.forEach(function (code) {\n    if (code < 400) {\n        return;\n    }\n\n    var name = codeToErrorName(code);\n\n    module.exports[name] = function (cause, message) {\n        var index = 1;\n        var opts = {\n            statusCode: code\n        };\n\n        if (cause && cause instanceof Error) {\n            opts.cause = cause;\n            opts.constructorOpt = arguments.callee;\n        } else if (typeof (cause) === 'object') {\n            opts.body = cause.body;\n            opts.cause = cause.cause;\n            opts.constructorOpt = cause.constructorOpt;\n            opts.message = cause.message;\n            opts.statusCode = cause.statusCode || code;\n        } else {\n            opts.constructorOpt = arguments.callee;\n            index = 0;\n        }\n\n        var args = slice(arguments, index);\n        args.unshift(opts);\n        HttpError.apply(this, args);\n    };\n    util.inherits(module.exports[name], HttpError);\n\n    module.exports[name].displayName =\n        module.exports[name].prototype.name =\n            name;\n});\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/errors/rest_error.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n// Because we are constructing error objects dynamically, we use an anonymous\n// function as the 'base constructor' then use arguments.callee to fill that in.\n// strict mode disallows agruments.callee, disable both of these rules.\n\n/* eslint-disable strict, no-caller */\n\nvar util = require('util');\n\nvar assert = require('assert-plus');\n\nvar httpErrors = require('./http_error');\n\n\n///--- Globals\n\nvar slice = Function.prototype.call.bind(Array.prototype.slice);\n\nvar HttpError = httpErrors.HttpError;\n\nvar CODES = {\n    BadDigest: 400,\n    BadMethod: 405,\n    Internal: 500, // Don't have InternalErrorError\n    InvalidArgument: 409,\n    InvalidContent: 400,\n    InvalidCredentials: 401,\n    InvalidHeader: 400,\n    InvalidVersion: 400,\n    MissingParameter: 409,\n    NotAuthorized: 403,\n    PreconditionFailed: 412,\n    RequestExpired: 400,\n    RequestThrottled: 429,\n    ResourceNotFound: 404,\n    WrongAccept: 406\n};\n\n\n///--- API\n\nfunction RestError(options) {\n    assert.object(options, 'options');\n\n    options.constructorOpt = options.constructorOpt || RestError;\n    HttpError.apply(this, arguments);\n\n    var self = this;\n    this.restCode = options.restCode || 'Error';\n    this.body = options.body || {\n        code: self.restCode,\n        message: options.message || self.message\n    };\n}\nutil.inherits(RestError, HttpError);\n\n\n///--- Exports\n\nmodule.exports = {\n    RestError: RestError\n};\n\nObject.keys(CODES).forEach(function (k) {\n    var name = k;\n\n    if (!/\\w+Error$/.test(name)) {\n        name += 'Error';\n    }\n\n    module.exports[name] = function (cause, message) {\n        var index = 1;\n        var opts = {\n            restCode: (k === 'Internal' ? 'InternalError' : k),\n            statusCode: CODES[k]\n        };\n\n        opts.constructorOpt = arguments.callee;\n\n        if (cause && cause instanceof Error) {\n            opts.cause = cause;\n        } else if (typeof (cause) === 'object') {\n            opts.body = cause.body;\n            opts.cause = cause.cause;\n            opts.message = cause.message;\n            opts.statusCode = cause.statusCode || CODES[k];\n        } else {\n            index = 0;\n        }\n\n        var args = slice(arguments, index);\n        args.unshift(opts);\n        RestError.apply(this, args);\n    };\n    util.inherits(module.exports[name], RestError);\n    module.exports[name].displayName =\n        module.exports[name].prototype.name =\n            name;\n});\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/http_date.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n/**\n * takes an instance of a date object, formats it UTC\n *     e.g., Wed, 17 Jun 2015 01:30:26 GMT\n * @public\n * @function httpDate\n * @param    {Object} now a date object\n * @returns  {String}     formatted dated object\n */\nmodule.exports = function httpDate(now) {\n    if (!now) {\n        now = new Date();\n    }\n\n    return (now.toUTCString());\n};\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/formatters/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\nmodule.exports = {\n    'application/javascript; q=0.1': require('./jsonp'),\n    'application/json; q=0.4': require('./json'),\n    'text/plain; q=0.3': require('./text'),\n    'application/octet-stream; q=0.2': require('./binary')\n};\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/formatters/jsonp.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSONP formatter. like JSON, but with a callback invocation.\n * @public\n * @function formatJSONP\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatJSONP(req, res, body, cb) {\n    if (!body) {\n        res.setHeader('Content-Length', 0);\n        return (null);\n    }\n\n    if (body instanceof Error) {\n        if ((body.restCode || body.httpCode) && body.body) {\n            body = body.body;\n        } else {\n            body = {\n                message: body.message\n            };\n        }\n    }\n\n    if (Buffer.isBuffer(body)) {\n        body = body.toString('base64');\n    }\n\n    var _cb = req.query.callback || req.query.jsonp;\n    var data;\n\n    if (_cb) {\n        data = 'typeof ' + _cb + ' === \\'function\\' && ' +\n                _cb + '(' + JSON.stringify(body) + ');';\n    } else {\n        data = JSON.stringify(body);\n    }\n\n    res.setHeader('Content-Length', Buffer.byteLength(data));\n    return cb(null, data);\n}\n\nmodule.exports = formatJSONP;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/formatters/json.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSON formatter.\n * @public\n * @function formatJSON\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatJSON(req, res, body, cb) {\n    if (body instanceof Error) {\n        // snoop for RestError or HttpError, but don't rely on\n        // instanceof\n        res.statusCode = body.statusCode || 500;\n\n        if (body.body) {\n            body = body.body;\n        } else {\n            body = {\n                message: body.message\n            };\n        }\n    } else if (Buffer.isBuffer(body)) {\n        body = body.toString('base64');\n    }\n\n    var data = JSON.stringify(body);\n    res.setHeader('Content-Length', Buffer.byteLength(data));\n\n    return cb(null, data);\n}\n\nmodule.exports = formatJSON;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/formatters/text.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * JSONP formatter. like JSON, but with a callback invocation.\n * @public\n * @function formatJSONP\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {String}\n */\nfunction formatText(req, res, body, cb) {\n    if (body instanceof Error) {\n        res.statusCode = body.statusCode || 500;\n        body = body.message;\n    } else if (typeof (body) === 'object') {\n        body = JSON.stringify(body);\n    } else {\n        body = body.toString();\n    }\n\n    res.setHeader('Content-Length', Buffer.byteLength(body));\n    return cb(null, body);\n}\n\nmodule.exports = formatText;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/formatters/binary.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\n/**\n * binary formatter.\n * @public\n * @function formatBinary\n * @param    {Object} req  the request object\n * @param    {Object} res  the response object\n * @param    {Object} body response body\n * @param    {Function} cb cb\n * @returns  {Buffer}\n */\nfunction formatBinary(req, res, body, cb) {\n    if (body instanceof Error) {\n        res.statusCode = body.statusCode || 500;\n    }\n\n    if (!Buffer.isBuffer(body)) {\n        body = new Buffer(body.toString());\n    }\n\n    res.setHeader('Content-Length', body.length);\n    return cb(null, body);\n}\n\nmodule.exports = formatBinary;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Exports\n\nmodule.exports = {\n    acceptParser: require('./accept'),\n    auditLogger: require('./audit'),\n    authorizationParser: require('./authorization'),\n    bodyParser: require('./body_parser'),\n    conditionalRequest: require('./conditional_request'),\n    CORS: require('./cors'),\n    dateParser: require('./date'),\n    jsonp: require('./jsonp'),\n    urlEncodedBodyParser: require('./form_body_parser'),\n    requestLogger: require('./bunyan'),\n    gzipResponse: require('./gzip'),\n    fullResponse: require('./full_response'),\n    jsonBodyParser: require('./json_body_parser'),\n    multipartBodyParser: require('./multipart_body_parser'),\n    queryParser: require('./query'),\n    requestExpiry: require('./request_expiry'),\n    sanitizePath: require('./pre/pre_path'),\n    serveStatic: require('./static'),\n    throttle: require('./throttle'),\n\n    pre: {\n        pause: require('./pre/pause'),\n        sanitizePath: require('./pre/pre_path'),\n        userAgentConnection: require('./pre/user_agent')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/accept.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\n\nvar NotAcceptableError = require('../errors').NotAcceptableError;\n\n\n/**\n * Returns a plugin that will check the client's Accept header can be handled\n * by this server.\n *\n * Note you can get the set of types allowed from a restify server by doing\n * `server.acceptable`.\n *\n * @public\n * @function acceptParser\n * @throws   {NotAcceptableError}\n * @param    {String}    acceptable array of accept types.\n * @returns  {Function}             restify handler.\n */\nfunction acceptParser(acceptable) {\n    if (!Array.isArray(acceptable)) {\n        acceptable = [acceptable];\n    }\n    assert.arrayOfString(acceptable, 'acceptable');\n\n    acceptable = acceptable.filter(function (a) {\n        return (a);\n    }).map(function (a) {\n            return ((a.indexOf('/') === -1) ? mime.lookup(a) : a);\n        }).filter(function (a) {\n            return (a);\n        });\n\n    var e = new NotAcceptableError('Server accepts: ' + acceptable.join());\n\n    function parseAccept(req, res, next) {\n        if (req.accepts(acceptable)) {\n            next();\n            return;\n        }\n\n        res.json(e);\n        next(false);\n    }\n\n    return (parseAccept);\n}\n\nmodule.exports = acceptParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/audit.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar bunyan = require('bunyan');\n\nvar HttpError = require('../errors').HttpError;\n\n\n///--- API\n\n/**\n * Returns a Bunyan audit logger suitable to be used in a server.on('after')\n * event.  I.e.:\n *\n * server.on('after', restify.auditLogger({ log: myAuditStream }));\n *\n * This logs at the INFO level.\n *\n * @public\n * @function auditLogger\n * @param   {Object}   options at least a bunyan logger (log).\n * @returns {Function}         to be used in server.after.\n */\nfunction auditLogger(options) {\n    assert.object(options, 'options');\n    assert.object(options.log, 'options.log');\n    var errSerializer = bunyan.stdSerializers.err;\n\n    if (options.log.serializers && options.log.serializers.err) {\n        errSerializer = options.log.serializers.err;\n    }\n\n    var log = options.log.child({\n        audit: true,\n        serializers: {\n            err: errSerializer,\n            req: function auditRequestSerializer(req) {\n                if (!req) {\n                    return (false);\n                }\n\n                var timers = {};\n                (req.timers || []).forEach(function (time) {\n                    var t = time.time;\n                    var _t = Math.floor((1000000 * t[0]) +\n                        (t[1] / 1000));\n                    timers[time.name] = _t;\n                });\n                return ({\n                    // account for native and queryParser plugin usage\n                    query: (typeof req.query === 'function') ?\n                            req.query() : req.query,\n                    method: req.method,\n                    url: req.url,\n                    headers: req.headers,\n                    httpVersion: req.httpVersion,\n                    trailers: req.trailers,\n                    version: req.version(),\n                    body: options.body === true ?\n                        req.body : undefined,\n                    timers: timers\n                });\n            },\n            res: function auditResponseSerializer(res) {\n                if (!res) {\n                    return (false);\n                }\n\n\n                var body;\n\n                if (options.body === true) {\n                    if (res._body instanceof HttpError) {\n                        body = res._body.body;\n                    } else {\n                        body = res._body;\n                    }\n                }\n\n                return ({\n                    statusCode: res.statusCode,\n                    headers: res._headers,\n                    trailer: res._trailer || false,\n                    body: body\n                });\n            }\n        }\n    });\n\n    function audit(req, res, route, err) {\n        var latency = res.get('Response-Time');\n\n        if (typeof (latency) !== 'number') {\n            latency = Date.now() - req._time;\n        }\n\n        var obj = {\n            remoteAddress: req.connection.remoteAddress,\n            remotePort: req.connection.remotePort,\n            req_id: req.getId(),\n            req: req,\n            res: res,\n            err: err,\n            latency: latency,\n            secure: req.secure,\n            _audit: true\n        };\n\n        log.info(obj, 'handled: %d', res.statusCode);\n\n        return (true);\n    }\n\n    return (audit);\n}\n\n\n///-- Exports\n\nmodule.exports = auditLogger;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/authorization.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar httpSignature = require('http-signature');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar InvalidHeaderError = errors.InvalidHeaderError;\n\nvar OPTIONS = {\n    algorithms: [\n        'rsa-sha1',\n        'rsa-sha256',\n        'rsa-sha512',\n        'dsa-sha1',\n        'hmac-sha1',\n        'hmac-sha256',\n        'hmac-sha512'\n    ]\n};\n\n\n///--- Helpers\n\nfunction parseBasic(string) {\n    var decoded;\n    var index;\n    var pieces;\n\n    decoded = (new Buffer(string, 'base64')).toString('utf8');\n\n    if (!decoded) {\n        throw new InvalidHeaderError('Authorization header invalid');\n    }\n\n    index = decoded.indexOf(':');\n\n    if (index === -1) {\n        pieces = [decoded];\n    } else {\n        pieces = [decoded.slice(0, index), decoded.slice(index + 1)];\n    }\n\n    if (!pieces || typeof (pieces[0]) !== 'string') {\n        throw new InvalidHeaderError('Authorization header invalid');\n    }\n\n    // Allows for usernameless authentication\n    if (!pieces[0]) {\n        pieces[0] = null;\n    }\n\n    // Allows for passwordless authentication\n    if (!pieces[1]) {\n        pieces[1] = null;\n    }\n\n    return ({\n        username: pieces[0],\n        password: pieces[1]\n    });\n}\n\n\nfunction parseSignature(request, options) {\n    options = options || {};\n    options.algorithms = OPTIONS.algorithms;\n\n    try {\n        return (httpSignature.parseRequest(request, options));\n    } catch (e) {\n        throw new InvalidHeaderError('Authorization header invalid: ' +\n            e.message);\n    }\n}\n\n\n/**\n * Returns a plugin that will parse the client's Authorization header.\n *\n * Subsequent handlers will see `req.authorization`, which looks like:\n *\n * {\n *   scheme: <Basic|Signature|...>,\n *   credentials: <Undecoded value of header>,\n *   basic: {\n *     username: $user\n *     password: $password\n *   }\n * }\n *\n * `req.username` will also be set, and defaults to 'anonymous'.\n *\n * @public\n * @function authorizationParser\n * @throws   {InvalidArgumentError}\n * @param    {Object} options an options object\n * @returns  {Function}\n */\nfunction authorizationParser(options) {\n\n    function parseAuthorization(req, res, next) {\n        req.authorization = {};\n        req.username = 'anonymous';\n\n        if (!req.headers.authorization) {\n            return (next());\n        }\n\n        var pieces = req.headers.authorization.split(' ', 2);\n\n        if (!pieces || pieces.length !== 2) {\n            var e = new InvalidHeaderError('BasicAuth content ' +\n                'is invalid.');\n            return (next(e));\n        }\n\n        req.authorization.scheme = pieces[0];\n        req.authorization.credentials = pieces[1];\n\n        try {\n            switch (pieces[0].toLowerCase()) {\n                case 'basic':\n                    req.authorization.basic = parseBasic(pieces[1]);\n                    req.username = req.authorization.basic.username;\n                    break;\n\n                case 'signature':\n                    req.authorization.signature =\n                        parseSignature(req, options);\n                    req.username =\n                        req.authorization.signature.keyId;\n                    break;\n\n                default:\n                    break;\n            }\n        } catch (e2) {\n            return (next(e2));\n        }\n\n        return (next());\n    }\n\n    return (parseAuthorization);\n}\n\nmodule.exports = authorizationParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\nvar bodyReader = require('./body_reader');\nvar jsonParser = require('./json_body_parser');\nvar formParser = require('./form_body_parser');\nvar multipartParser = require('./multipart_body_parser');\nvar fieldedTextParser = require('./fielded_text_body_parser.js');\n\n\n///--- Globals\n\nvar UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;\n\n\n///--- API\n\n/**\n * parse the body of an incoming request.\n * @public\n * @function bodyParser\n * @throws   {UnsupportedMediaTypeError}\n * @param    {Object} options an option object\n * @returns  {Array}\n */\nfunction bodyParser(options) {\n    assert.optionalObject(options, 'options');\n    options = options || {};\n    options.bodyReader = true;\n\n    var read = bodyReader(options);\n    var parseForm = formParser(options);\n    var parseJson = jsonParser(options);\n    var parseMultipart = multipartParser(options);\n    var parseFieldedText = fieldedTextParser(options);\n\n    function parseBody(req, res, next) {\n        // Allow use of 'requestBodyOnGet' flag to allow for merging of\n        // the request body of a GET request into req.params\n        if (req.method === 'HEAD') {\n            next();\n            return;\n        }\n\n        if (req.method === 'GET') {\n            if (!options.requestBodyOnGet) {\n                next();\n                return;\n            }\n        }\n\n        if (req.contentLength() === 0 && !req.isChunked()) {\n            next();\n            return;\n        }\n\n        var parser;\n        var type = req.contentType().toLowerCase();\n\n        switch (type) {\n            case 'application/json':\n                parser = parseJson[0];\n                break;\n            case 'application/x-www-form-urlencoded':\n                parser = parseForm[0];\n                break;\n            case 'multipart/form-data':\n                parser = parseMultipart;\n                break;\n            case 'text/tsv':\n                parser = parseFieldedText;\n                break;\n            case 'text/tab-separated-values':\n                parser = parseFieldedText;\n                break;\n            case 'text/csv':\n                parser = parseFieldedText;\n                break;\n\n            default:\n                break;\n        }\n\n        if (parser) {\n            parser(req, res, next);\n        } else if (options && options.rejectUnknown) {\n            next(new UnsupportedMediaTypeError(type));\n        } else {\n            next();\n        }\n    }\n\n    return ([read, parseBody]);\n}\n\nmodule.exports = bodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/body_reader.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar BadDigestError = errors.BadDigestError;\nvar RequestEntityTooLargeError = errors.RequestEntityTooLargeError;\nvar PayloadTooLargeError = errors.PayloadTooLargeError;\n\nvar MD5_MSG = 'Content-MD5 \\'%s\\' didn\\'t match \\'%s\\'';\n\n\n///--- Helpers\n\nfunction createBodyWriter(req) {\n    var buffers = [];\n\n    var contentType = req.contentType();\n    var isText = false;\n\n    if (!contentType ||\n        contentType === 'application/json' ||\n        contentType === 'application/x-www-form-urlencoded' ||\n        contentType === 'multipart/form-data' ||\n        contentType.substr(0, 5) === 'text/') {\n        isText = true;\n    }\n\n    req.body = new Buffer(0);\n    return {\n        write: function (chunk) {\n            buffers.push(chunk);\n        },\n        end: function () {\n            req.body = Buffer.concat(buffers);\n\n            if (isText) {\n                req.body = req.body.toString('utf8');\n            }\n        }\n    };\n}\n\n\n///--- API\n\n/**\n * reads the body of the request.\n * @public\n * @function bodyReader\n * @throws   {BadDigestError | PayloadTooLargeError}\n * @param    {Object} options an options object\n * @returns  {Function}\n */\nfunction bodyReader(options) {\n    options = options || {};\n    assert.object(options, 'options');\n\n    var maxBodySize = options.maxBodySize || 0;\n\n    function readBody(req, res, next) {\n        if ((req.getContentLength() === 0 && !req.isChunked()) ||\n            req.contentType() === 'multipart/form-data' ||\n            req.contentType() === 'application/octet-stream') {\n            next();\n            return;\n        }\n        var bodyWriter = createBodyWriter(req);\n\n        var bytesReceived = 0;\n        var digest;\n        var gz;\n        var hash;\n        var md5;\n\n        if ((md5 = req.headers['content-md5'])) {\n            hash = crypto.createHash('md5');\n        }\n\n        function done() {\n            var errorMessage;\n            bodyWriter.end();\n\n            if (maxBodySize && bytesReceived > maxBodySize) {\n                var msg = 'Request body size exceeds ' +\n                    maxBodySize;\n\n                // Between Node 0.12 and 4 http status code messages changed\n                // RequestEntityTooLarge was changed to PayloadTooLarge\n                // this check is to maintain backwards compatibility\n                if (PayloadTooLargeError !== undefined) {\n                    errorMessage = new PayloadTooLargeError(msg);\n                } else {\n                    errorMessage = new RequestEntityTooLargeError(msg);\n                }\n\n                next(errorMessage);\n                return;\n            }\n\n            if (!req.body.length) {\n                next();\n                return;\n            }\n\n            if (hash && md5 !== (digest = hash.digest('base64'))) {\n                errorMessage = new BadDigestError(MD5_MSG, md5, digest);\n                next(errorMessage);\n                return;\n            }\n\n            next();\n        }\n\n        if (req.headers['content-encoding'] === 'gzip') {\n            gz = zlib.createGunzip();\n            gz.on('data', bodyWriter.write);\n            gz.once('end', done);\n            req.once('end', gz.end.bind(gz));\n        } else {\n            req.once('end', done);\n        }\n\n        req.on('data', function onRequestData(chunk) {\n            if (maxBodySize) {\n                bytesReceived += chunk.length;\n\n                if (bytesReceived > maxBodySize) {\n                    return;\n                }\n            }\n\n            if (hash) {\n                hash.update(chunk, 'binary');\n            }\n\n            if (gz) {\n                gz.write(chunk);\n            } else {\n                bodyWriter.write(chunk);\n            }\n        });\n\n        req.once('error', next);\n        req.resume();\n    }\n\n    return (readBody);\n}\n\nmodule.exports = bodyReader;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/json_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar bodyReader = require('./body_reader');\nvar errors = require('../errors');\n\n\n///--- API\n\n/**\n * parses json body from the request.\n * @public\n * @function jsonBodyParser\n * @param    {Object}               options an options object\n * @throws   {InvalidContentError}          on bad input\n * @returns  {Function}\n */\nfunction jsonBodyParser(options) {\n    assert.optionalObject(options, 'options');\n    options = options || {};\n\n    var override = options.overrideParams;\n\n    function parseJson(req, res, next) {\n        if (req.getContentType() !== 'application/json' || !req.body) {\n            next();\n            return;\n        }\n\n        var params;\n\n        try {\n            params = JSON.parse(req.body, options.reviver);\n        } catch (e) {\n            next(new errors.InvalidContentError('Invalid JSON: ' +\n                e.message));\n            return;\n        }\n\n        if (options.mapParams !== false) {\n            if (Array.isArray(params)) {\n                req.params = params;\n            } else if (typeof (params) === 'object' && params !== null) {\n                Object.keys(params).forEach(function (k) {\n                    var p = req.params[k];\n\n                    if (p && !override) {\n                        return (false);\n                    }\n                    req.params[k] = params[k];\n                    return (true);\n                });\n            } else {\n                req.params = params || req.params;\n            }\n        } else {\n            req._body = req.body;\n        }\n\n        req.body = params;\n\n        next();\n    }\n\n    var chain = [];\n\n    if (!options.bodyReader) {\n        chain.push(bodyReader(options));\n    }\n    chain.push(parseJson);\n    return (chain);\n}\n\nmodule.exports = jsonBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/form_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\nvar querystring = require('qs');\n\nvar bodyReader = require('./body_reader');\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar MIME_TYPE = 'application/x-www-form-urlencoded';\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body IFF the\n * contentType is application/x-www-form-urlencoded.\n *\n * If req.params already contains a given key, that key is skipped and an\n * error is logged.\n *\n * @public\n * @function urlEncodedBodyParser\n * @param   {Object}    options an option sobject\n * @returns {Function}\n */\nfunction urlEncodedBodyParser(options) {\n    options = options || {};\n    assert.object(options, 'options');\n\n    var override = options.overrideParams;\n\n    function parseUrlEncodedBody(req, res, next) {\n        if (req.getContentType() !== MIME_TYPE || !req.body) {\n            next();\n            return;\n        }\n\n        try {\n            var params = querystring.parse(req.body);\n\n            if (options.mapParams !== false) {\n                var keys = Object.keys(params);\n                keys.forEach(function (k) {\n                    var p = req.params[k];\n\n                    if (p && !override) {\n                        return (false);\n                    }\n\n                    req.params[k] = params[k];\n                    return (true);\n                });\n            } else {\n                req._body = req.body;\n                req.body = params;\n            }\n        } catch (e) {\n            next(new errors.InvalidContentError(e.message));\n            return;\n        }\n\n        req.log.trace('req.params now: %j', req.params);\n        next();\n    }\n\n    var chain = [];\n\n    if (!options.bodyReader) {\n        chain.push(bodyReader(options));\n    }\n    chain.push(parseUrlEncodedBody);\n    return (chain);\n}\n\nmodule.exports = urlEncodedBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/multipart_body_parser.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar fs = require('fs');\n\nvar assert = require('assert-plus');\nvar formidable = require('formidable');\nvar once = require('once');\nvar vasync = require('vasync');\n\nvar errors = require('../errors');\n\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body IFF the\n * contentType is multipart/form-data\n *\n * If req.params already contains a given key, that key is skipped and an\n * error is logged.\n * @public\n * @function multipartBodyParser\n * @param    {Object}          options an options object\n * @throws   {BadRequestError}\n * @returns  {Function}\n */\nfunction multipartBodyParser(options) {\n    if (!options) {\n        options = {};\n    }\n    assert.object(options, 'options');\n    assert.optionalBool(options.overrideParams, 'options.overrideParams');\n    assert.optionalBool(options.multiples, 'options.multiples');\n    assert.optionalBool(options.keepExtensions, 'options.keepExtensions');\n    assert.optionalString(options.uploadDir, 'options.uploadDir');\n    assert.optionalNumber(options.maxFieldsSize, 'options.maxFieldsSize');\n    assert.optionalString(options.hash, 'options.hash');\n    assert.optionalFunc(options.multipartFileHandler,\n                        'options.multipartFileHandler');\n    assert.optionalFunc(options.multipartHandler, 'options.multipartHandler');\n    assert.optionalBool(options.mapParams, 'options.mapParams');\n    assert.optionalBool(options.mapFiles, 'options.mapFiles');\n\n    var override = options.overrideParams;\n\n    function parseMultipartBody(req, res, next) {\n        next = once(next);\n\n        if (req.getContentType() !== 'multipart/form-data' ||\n            (req.getContentLength() === 0 && !req.isChunked())) {\n            return (next());\n        }\n\n        var form = new formidable.IncomingForm();\n\n        // enable multiple files on a single upload field\n        // (html5 multiple attribute)\n        form.multiples = options.multiples || false;\n        form.keepExtensions = options.keepExtensions ? true : false;\n\n        if (options.uploadDir) {\n            form.uploadDir = options.uploadDir;\n        }\n\n        if (options.maxFieldsSize) {\n            form.maxFieldsSize = options.maxFieldsSize;\n        }\n\n        if (options.hash) {\n            form.hash = options.hash;\n        }\n\n        form.onPart = function onPart(part) {\n            if (part.filename && options.multipartFileHandler) {\n                options.multipartFileHandler(part, req);\n            } else if (!part.filename && options.multipartHandler) {\n                options.multipartHandler(part, req);\n            } else {\n                form.handlePart(part);\n            }\n        };\n\n        form.parse(req, function (err, fields, files) {\n            if (err) {\n                return (next(new errors.BadRequestError(err.message)));\n            }\n\n            req.body = fields;\n            req.files = files;\n\n            if (options.mapParams !== false) {\n                Object.keys(fields).forEach(function (k) {\n                    if (req.params[k] && !override) {\n                        return;\n                    }\n\n                    req.params[k] = fields[k];\n                });\n\n                if (options.mapFiles) {\n                    var barrier = vasync.barrier();\n                    barrier.on('drain', function () {\n                        return next();\n                    });\n\n                    barrier.start('fs');\n                    Object.keys(files).forEach(function (f) {\n                        if (req.params[f] && !override) {\n                            return;\n                        }\n                        barrier.start('fs' + f);\n                        fs.readFile(files[f].path, function (ex, data) {\n                            barrier.done('fs' + f);\n                            /*\n                             * We want to stop the request here, if there's an\n                             * error trying to read the file from disk.\n                             * Ideally we'd like to stop the other oustanding\n                             * file reads too, but there's no way to cancel in\n                             * flight fs reads.  So we just return an error, and\n                             * be grudgingly let the other file reads finish.\n                             */\n                            if (ex) {\n                                return next(new errors.InternalError(ex,\n                                         'unable to read file' + f));\n                            }\n                            req.params[f] = data;\n                            return (true);\n                        });\n                    });\n                    barrier.done('fs');\n                } else {\n                    return next();\n                }\n            } else {\n                return next();\n            }\n\n        });\n\n        return (false);\n    }\n\n    return (parseMultipartBody);\n}\n\nmodule.exports = multipartBodyParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/fielded_text_body_parser.js":"/**\n * Dependencies\n */\n\n'use strict';\n\nvar csv = require('csv');\nvar assert = require('assert-plus');\n\n///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body if the\n * contentType is `text/csv` or `text/tsv`\n * @public\n * @function fieldedTextParser\n * @param    {Object}    options an options object\n * @returns  {Function}\n */\nfunction fieldedTextParser(options) {\n\n    assert.optionalObject(options, 'options');\n    options = options || {};\n\n    function parseFieldedText(req, res, next) {\n\n        var contentType = req.getContentType();\n\n        if (contentType !== 'text/csv' &&\n            contentType !== 'text/tsv' &&\n            contentType !== 'text/tab-separated-values' || !req.body) {\n            next();\n            return;\n        }\n\n\n        var hDelimiter = req.headers['x-content-delimiter'];\n        var hEscape = req.headers['x-content-escape'];\n        var hQuote = req.headers['x-content-quote'];\n        var hColumns = req.headers['x-content-columns'];\n\n\n        var delimiter = (contentType === 'text/tsv') ? '\\t' : ',';\n        delimiter = (hDelimiter) ? hDelimiter : delimiter;\n        var escape = (hEscape) ? hEscape : '\\\\';\n        var quote = (hQuote) ? hQuote : '\"';\n        var columns = (hColumns) ? hColumns : true;\n\n        var parserOptions = {\n            delimiter: delimiter,\n            quote: quote,\n            escape: escape,\n            columns: columns\n        };\n\n        csv.parse(req.body, parserOptions, function (err, parsedBody) {\n            if (err) {\n                return (next(err));\n            }\n\n            // Add an \"index\" property to every row\n            parsedBody.forEach(function (row, index) {\n                row.index = index;\n            });\n            req.body = parsedBody;\n            return (next());\n        });\n\n    }\n\n    return (parseFieldedText);\n\n}\n\nmodule.exports = fieldedTextParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/conditional_request.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar BadRequestError = errors.BadRequestError;\nvar PreconditionFailedError = errors.PreconditionFailedError;\n\nvar IF_MATCH_FAIL = 'if-match \\'%s\\' didn\\'t match etag \\'%s\\'';\nvar IF_NO_MATCH_FAIL = 'if-none-match \\'%s\\' matched etag \\'%s\\'';\nvar IF_MOD_FAIL = 'object was modified at \\'%s\\'; if-modified-since \\'%s\\'';\nvar IF_UNMOD_FAIL = 'object was modified at \\'%s\\'; if-unmodified-since \\'%s\\'';\n\n\n///--- API\n// Reference RFC2616 section 14 for an explanation of what this all does.\n\nfunction checkIfMatch(req, res, next) {\n    var clientETags;\n    var cur;\n    var etag = res.etag || res.getHeader('etag') || '';\n    var ifMatch;\n    var matched = false;\n\n    if ((ifMatch = req.headers['if-match'])) {\n\n        clientETags = ifMatch.split(/\\s*,\\s*/);\n\n        for (var i = 0; i < clientETags.length; i++) {\n            cur = clientETags[i];\n\n            // only strong comparison\n\n            cur = cur.replace(/^W\\//, '');\n            cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n            if (cur === '*' || cur === etag) {\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {\n            var err = new PreconditionFailedError(IF_MATCH_FAIL,\n                ifMatch,\n                etag);\n            return (next(err));\n        }\n    }\n\n    return (next());\n}\n\n\nfunction checkIfNoneMatch(req, res, next) {\n    var clientETags;\n    var cur;\n    var etag = res.etag || res.getHeader('etag') || '';\n    var ifNoneMatch;\n    var matched = false;\n\n    if ((ifNoneMatch = req.headers['if-none-match'])) {\n\n        clientETags = ifNoneMatch.split(/\\s*,\\s*/);\n\n        for (var i = 0; i < clientETags.length; i++) {\n            cur = clientETags[i];\n\n            // ignore weak validation\n            cur = cur.replace(/^W\\//, '');\n            cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n            if (cur === '*' || cur === etag) {\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {\n            return (next());\n        }\n\n        if (req.method !== 'GET' && req.method !== 'HEAD') {\n            var err = new PreconditionFailedError(IF_NO_MATCH_FAIL,\n                ifNoneMatch,\n                etag);\n            return (next(err));\n        }\n\n        res.send(304);\n        return (next(false));\n    }\n\n    return (next());\n}\n\n\nfunction checkIfModified(req, res, next) {\n    var code;\n    var err;\n    var ctime = req.header('if-modified-since');\n    var mtime = res.mtime || res.header('Last-Modified') || '';\n\n    if (!mtime || !ctime) {\n        next();\n        return;\n    }\n\n    try {\n        //\n        // TODO handle Range header modifications\n        //\n        // Note: this is not technically correct as per 2616 -\n        // 2616 only specifies semantics for GET requests, not\n        // any other method - but using if-modified-since with a\n        // PUT or DELETE seems like returning 412 is sane\n        //\n        if (Date.parse(mtime) <= Date.parse(ctime)) {\n            switch (req.method) {\n                case 'GET':\n                case 'HEAD':\n                    code = 304;\n                    break;\n\n                default:\n                    err = new PreconditionFailedError(IF_MOD_FAIL,\n                        mtime,\n                        ctime);\n                    break;\n            }\n        }\n    } catch (e) {\n        next(new BadRequestError(e.message));\n        return;\n    }\n\n    if (code !== undefined) {\n        res.send(code);\n        next(false);\n        return;\n    }\n\n    next(err);\n}\n\n\nfunction checkIfUnmodified(req, res, next) {\n    var err;\n    var ctime = req.headers['if-unmodified-since'];\n    var mtime = res.mtime || res.header('Last-Modified') || '';\n\n    if (!mtime || !ctime) {\n        next();\n        return;\n    }\n\n    try {\n        if (Date.parse(mtime) > Date.parse(ctime)) {\n            err = new PreconditionFailedError(IF_UNMOD_FAIL,\n                mtime,\n                ctime);\n        }\n    } catch (e) {\n        next(new BadRequestError(e.message));\n        return;\n    }\n\n    next(err);\n}\n\n\n///--- Exports\n\n/**\n * Returns a set of plugins that will compare an already set ETag header with\n * the client's If-Match and If-None-Match header, and an already set\n * Last-Modified header with the client's If-Modified-Since and\n * If-Unmodified-Since header.\n * @public\n * @throws {BadRequestError | PreconditionFailedError}\n * @function conditionalRequest\n * @returns  {Array}\n */\nfunction conditionalRequest() {\n    var chain = [\n        checkIfMatch,\n        checkIfNoneMatch,\n        checkIfModified,\n        checkIfUnmodified\n    ];\n    return (chain);\n}\n\nmodule.exports = conditionalRequest;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/cors.js":"// Copyright 2013 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n///--- Globals\n\nvar ALLOW_HEADERS = [\n    'accept',\n    'accept-version',\n    'content-type',\n    'request-id',\n    'origin',\n    'x-api-version',\n    'x-request-id'\n];\n\nvar EXPOSE_HEADERS = [\n    'api-version',\n    'content-length',\n    'content-md5',\n    'content-type',\n    'date',\n    'request-id',\n    'response-time'\n];\n\n// Normal\nvar AC_ALLOW_ORIGIN = 'Access-Control-Allow-Origin';\nvar AC_ALLOW_CREDS = 'Access-Control-Allow-Credentials';\nvar AC_EXPOSE_HEADERS = 'Access-Control-Expose-Headers';\n\n\n///--- Internal Functions\n\nfunction matchOrigin(req, origins) {\n    var origin = req.headers.origin;\n\n    function belongs(o) {\n        if (origin === o || o === '*') {\n            origin = o;\n            return (true);\n        }\n\n        return (false);\n    }\n\n    return ((origin && origins.some(belongs)) ? origin : false);\n}\n\n\n///--- API\n\n/**\n * From http://www.w3.org/TR/cors/#resource-processing-model\n *\n * If \"simple\" request (paraphrased):\n *\n * 1. If the Origin header is not set, or if the value of Origin is not a\n *    case-sensitive match to any values listed in `opts.origins`, do not\n *    send any CORS headers\n *\n * 2. If the resource supports credentials add a single\n *    'Access-Control-Allow-Credentials' header with the value as \"true\", and\n *    ensure 'AC-Allow-Origin' is not '*', but is the request header value,\n *    otherwise add a single Access-Control-Allow-Origin header, with either the\n *    value of the Origin header or the string \"*\" as value\n *\n * 3. Add Access-Control-Expose-Headers as appropriate\n *\n * Pre-flight requests are handled by the router internally\n *\n * @public\n * @function cors\n * @param    {Object}   opts an options object\n * @returns  {Function}\n */\nfunction cors(opts) {\n    assert.optionalObject(opts, 'options');\n    opts = opts || {};\n    assert.optionalArrayOfString(opts.origins, 'options.origins');\n    assert.optionalBool(opts.credentials, 'options.credentials');\n    assert.optionalArrayOfString(opts.headers, 'options.headers');\n\n    cors.credentials = opts.credentials;\n    cors.origins = opts.origins || ['*'];\n\n    var headers = (opts.headers || []).slice(0);\n    var origins = opts.origins || ['*'];\n\n    EXPOSE_HEADERS.forEach(function (h) {\n        if (headers.indexOf(h) === -1) {\n            headers.push(h);\n        }\n    });\n\n    // Handler for simple requests\n    function restifyCORSSimple(req, res, next) {\n        var origin;\n\n        if (!(origin = matchOrigin(req, origins))) {\n            next();\n            return;\n        }\n\n        function corsOnHeader() {\n            origin = req.headers.origin;\n\n            if (opts.credentials) {\n                res.setHeader(AC_ALLOW_ORIGIN, origin);\n                res.setHeader(AC_ALLOW_CREDS, 'true');\n            } else {\n                res.setHeader(AC_ALLOW_ORIGIN, origin);\n            }\n\n            res.setHeader(AC_EXPOSE_HEADERS, headers.join(', '));\n        }\n\n        res.once('header', corsOnHeader);\n        next();\n    }\n\n    return (restifyCORSSimple);\n}\n\n\n///--- Exports\n\nmodule.exports = cors;\n\n// All of these are needed for the pre-flight code over in lib/router.js\ncors.ALLOW_HEADERS = ALLOW_HEADERS;\ncors.EXPOSE_HEADERS = EXPOSE_HEADERS;\ncors.credentials = false;\ncors.origins = [];\ncors.matchOrigin = matchOrigin;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/date.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar InvalidHeaderError = errors.InvalidHeaderError;\nvar RequestExpiredError = errors.RequestExpiredError;\n\nvar BAD_MSG = 'Date header is invalid';\nvar OLD_MSG = 'Date header %s is too old';\n\n\n///--- API\n\n/**\n * Returns a plugin that will parse the Date header (if present) and check for\n * an \"expired\" request, where expired means the request originated at a time\n * before ($now - $clockSkew). The default clockSkew allowance is 5m (thanks\n * Kerberos!)\n * @public\n * @function dateParser\n * @throws   {RequestExpiredError | InvalidHeaderError}\n * @param    {Number}    clockSkew optional age of time (in seconds).\n * @returns  {Function}            restify handler.\n */\nfunction dateParser(clockSkew) {\n    if (!clockSkew) {\n        clockSkew = 300;\n    }\n    assert.number(clockSkew, 'clockSkew');\n\n    clockSkew = clockSkew * 1000;\n\n    function parseDate(req, res, next) {\n        if (!req.headers.date) {\n            return (next());\n        }\n\n        var e;\n        var date = req.headers.date;\n        var log = req.log;\n\n        try {\n            var now = Date.now();\n            var sent = new Date(date).getTime();\n\n            if (log.trace()) {\n                log.trace({\n                    allowedSkew: clockSkew,\n                    now: now,\n                    sent: sent\n                }, 'Checking clock skew');\n            }\n\n            if ((now - sent) > clockSkew) {\n                e = new RequestExpiredError(OLD_MSG, date);\n                return (next(e));\n            }\n\n\n        } catch (err) {\n            log.trace({\n                err: err\n            }, 'Bad Date header: %s', date);\n\n            e = new InvalidHeaderError(BAD_MSG, date);\n            return (next(e));\n        }\n\n        return (next());\n    }\n\n    return (parseDate);\n}\n\nmodule.exports = dateParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/jsonp.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar qs = require('qs');\n\n\n///--- API\n\n/**\n * parses the jsonp callback out of the request.\n * @public\n * @function jsonp\n * @returns  {Function}\n */\nfunction jsonp() {\n    function _jsonp(req, res, next) {\n        var q = req.getQuery();\n\n        // If the query plugin wasn't used, we need to hack it in now\n        if (typeof (q) === 'string') {\n            req.query = qs.parse(q);\n        }\n\n        if (req.query.callback || req.query.jsonp) {\n            res.setHeader('Content-Type', 'application/javascript');\n        }\n\n        next();\n    }\n\n    return (_jsonp);\n}\n\n\nmodule.exports = jsonp;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/bunyan.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\nvar shallowCopy = require('../utils').shallowCopy;\n\n\n///--- API\n\n/**\n * attaches bunyan logger to the request.\n * @public\n * @function requestLogger\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction requestLogger(options) {\n    assert.optionalObject(options);\n    options = options || {};\n\n    var props;\n\n    if (options.properties) {\n        props = shallowCopy(options.properties);\n    } else {\n        props = {};\n    }\n\n    if (options.serializers) {\n        props.serializers = options.serializers;\n    }\n\n    var headersToCopy = options.headers || [];\n\n    return function bunyan(req, res, next) {\n        if (!req.log && !options.log) {\n            next();\n            return;\n        }\n\n        var log = req.log || options.log;\n\n        props.req_id = req.getId();\n        headersToCopy.forEach(function (k) {\n\n            if (req.headers[k]) {\n                props[k] = req.headers[k];\n            }\n        });\n        req.log = log.child(props, props.serializers ? false : true);\n\n        if (props.req_id) {\n            delete props.req_id;\n        }\n\n        next();\n    };\n}\n\n\n///--- Exports\n\nmodule.exports = requestLogger;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/gzip.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\n\n\nfunction _writeHead(originalFunction) {\n    this.removeHeader('Content-Length');\n    originalFunction.apply(this, Array.prototype.slice.call(arguments, 1));\n}\n\n///--- API\n\n/**\n * gzips the response.\n * https://github.com/restify/node-restify/issues/284\n * @public\n * @function gzipResponse\n * @param   {Object}   opts an options object\n * @returns {Function}\n */\nfunction gzipResponse(opts) {\n    assert.optionalObject(opts, 'options');\n\n    function gzip(req, res, next) {\n        if (!req.acceptsEncoding('gzip')) {\n            next();\n            return;\n        }\n\n        var gz = zlib.createGzip(opts);\n\n        gz.on('data', res.write.bind(res));\n        gz.once('end', res.end.bind(res));\n        gz.on('drain', res.emit.bind(res, 'drain'));\n\n        var origWrite = res.write;\n        var origEnd = res.end;\n        var origWriteHead = res.writeHead;\n        res.handledGzip = function _handledGzip() {\n            res.write = origWrite;\n            res.end = origEnd;\n            res.writeHead = origWriteHead;\n        };\n\n        res.write = gz.write.bind(gz);\n        res.end = gz.end.bind(gz);\n\n        res.writeHead = _writeHead.bind(res, res.writeHead);\n        res.setHeader('Content-Encoding', 'gzip');\n        next();\n    }\n\n    return (gzip);\n}\n\n\n///--- Exports\n\nmodule.exports = gzipResponse;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/full_response.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar crypto = require('crypto');\n\nvar httpDate = require('../http_date');\n\n\n///--- Globals\n\nvar ALLOW_HEADERS = [\n    'Accept',\n    'Accept-Version',\n    'Content-Length',\n    'Content-MD5',\n    'Content-Type',\n    'Date',\n    'Api-Version',\n    'Response-Time'\n].join(', ');\n\nvar EXPOSE_HEADERS = [\n    'Api-Version',\n    'Request-Id',\n    'Response-Time'\n].join(', ');\n\n\n///--- API\n\nfunction setHeaders(req, res) {\n    var hash;\n    var now = new Date();\n    var methods;\n\n    if (!res.getHeader('Access-Control-Allow-Origin')) {\n        res.setHeader('Access-Control-Allow-Origin', '*');\n    }\n\n    if (!res.getHeader('Access-Control-Allow-Headers')) {\n        res.setHeader('Access-Control-Allow-Headers', ALLOW_HEADERS);\n    }\n\n    if (!res.getHeader('Access-Control-Allow-Methods')) {\n        if (res.methods && res.methods.length > 0) {\n            methods = res.methods.join(', ');\n            res.setHeader('Access-Control-Allow-Methods', methods);\n        }\n    }\n\n    if (!res.getHeader('Access-Control-Expose-Headers')) {\n        res.setHeader('Access-Control-Expose-Headers', EXPOSE_HEADERS);\n    }\n\n    if (!res.getHeader('Connection')) {\n        res.setHeader('Connection',\n            req.isKeepAlive() ? 'Keep-Alive' : 'close');\n    }\n\n    if (res._data && !res.getHeader('Content-MD5')) {\n        hash = crypto.createHash('md5');\n        hash.update(res._data);\n        res.setHeader('Content-MD5', hash.digest('base64'));\n    }\n\n    if (!res.getHeader('Date')) {\n        res.setHeader('Date', httpDate(now));\n    }\n\n    if (res.etag && !res.getHeader('Etag')) {\n        res.setHeader('Etag', res.etag);\n    }\n\n    if (!res.getHeader('Server')) {\n        res.setHeader('Server', res.serverName);\n    }\n\n    if (res.version && !res.getHeader('Api-Version')) {\n        res.setHeader('Api-Version', res.version);\n    }\n\n    if (!res.getHeader('Request-Id')) {\n        res.setHeader('Request-Id', req.getId());\n    }\n\n    if (!res.getHeader('Response-Time')) {\n        res.setHeader('Response-Time', now.getTime() - req._time);\n    }\n\n}\n\n\n/**\n * handles disappeared CORS headers.\n * https://github.com/restify/node-restify/issues/284\n * @public\n * @function fullResponse\n * @returns  {Function}\n */\nfunction fullResponse() {\n    function restifyResponseHeaders(req, res, next) {\n        res.once('header', function () {\n\n            // Restify 1.0 compatibility\n            if (res.defaultResponseFormatters) {\n                res.defaultResponseFormatters(res._data);\n            }\n\n            res.emit('beforeSend', res._data, res._body);\n\n            // end backwards-compatibility\n            return (setHeaders(req, res));\n        });\n\n        return (next());\n    }\n\n    return (restifyResponseHeaders);\n}\n\n\n///--- Exports\n\nmodule.exports = fullResponse;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/query.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar qs = require('qs');\nvar assert = require('assert-plus');\n\nvar EXPOSED_QS_OPTIONS = {\n    allowDots: assert.optionalBool,\n    arrayLimit: assert.optionalNumber,\n    depth: assert.optionalNumber,\n    parameterLimit: assert.optionalNumber,\n    parseArrays: assert.optionalBool,\n    plainObjects: assert.optionalBool,\n    strictNullHandling: assert.optionalBool\n\n    /*\n     * Exclusions (`qs.parse` options that restify does NOT expose):\n     * - `allowPrototypes`: It is strongly suggested against in qs docs.\n     * - `decoder`\n     * - `delimiter`: For query string parsing we shouldn't support anything\n     *   but the default '&'.\n     */\n};\n\n/**\n * Returns a plugin that will parse the query string, and merge the results\n * into req.query.\n *\n * Unless options.mapParams is false, they will also be mapped into req.params.\n * @public\n * @function queryParser\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction queryParser(options) {\n    if (!options) {\n        options = {};\n    }\n    assert.object(options, 'options');\n\n    /*\n     * Releases of restify 4.x up to 4.1.1 used qs@3 which effectively defaulted\n     * to `plainObjects=true` and `allowDots=true`. To maintain backward\n     * compatibility for the restify 4.x stream while using the latest qs\n     * version, we need to maintain those defaults. Note that restify-plugins\n     * changes back to the pre-restify-4.x behaviour. See test/query.test.js\n     * for more details.\n     */\n    var qsOptions = {\n        plainObjects: true,\n        allowDots: true\n    };\n    Object.keys(EXPOSED_QS_OPTIONS).forEach(function (k) {\n        EXPOSED_QS_OPTIONS[k](options[k], k); // assert type of this option\n\n        if (options.hasOwnProperty(k)) {\n            qsOptions[k] = options[k];\n        }\n    });\n\n    function parseQueryString(req, res, next) {\n        if (!req.getQuery()) {\n            req.query = {};\n            return (next());\n        }\n\n        req.query = qs.parse(req.getQuery(), qsOptions);\n\n        if (options.mapParams !== false) {\n            Object.keys(req.query).forEach(function (k) {\n                if (req.params[k] && !options.overrideParams) {\n                    return (false);\n                }\n\n                req.params[k] = req.query[k];\n                return (true);\n            });\n        }\n\n        return (next());\n    }\n\n    return (parseQueryString);\n}\n\nmodule.exports = queryParser;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/request_expiry.js":"'use strict';\n\nvar assert = require('assert-plus');\nvar GatewayTimeoutError = require('./../errors').GatewayTimeoutError;\n\n/**\n * A request expiry will use the headers to tell if the\n * incoming request has expired or not.  The header is\n * expected to be in absolute time since the epoch.\n * @public\n * @function requestExpiry\n * @param    {Object} options        an options object\n * @param    {String} options.header The header key to be used for\n *                                   the expiry time of each request.\n * @returns  {Function}\n */\nfunction requestExpiry(options) {\n    assert.object(options, 'options');\n    assert.string(options.header, 'options.header');\n    var headerKey = options.header;\n\n    return function (req, res, next) {\n        var expiry = req.headers[headerKey];\n\n        if (expiry) {\n            var expiryTime = Number(expiry);\n\n            // The request has expired\n            if (Date.now() > expiryTime) {\n                return next(new GatewayTimeoutError('Request has expired'));\n            }\n        }\n\n        // Happy case\n        return next();\n    };\n}\n\nmodule.exports = requestExpiry;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/pre/pre_path.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Helpers\n\n\n/**\n * Cleans up sloppy URLs on the request object, like /foo////bar/// to /foo/bar.\n * @private\n * @function strip\n * @param    {Object} path a url path to clean up\n * @returns  {String}\n */\nfunction strip(path) {\n    var cur;\n    var next;\n    var str = '';\n\n    for (var i = 0; i < path.length; i++) {\n        cur = path.charAt(i);\n\n        if (i !== path.length - 1) {\n            next = path.charAt(i + 1);\n        }\n\n        if (cur === '/' && (next === '/' || (next === '?' && i > 0))) {\n            continue;\n        }\n\n        str += cur;\n    }\n\n    return (str);\n}\n\n\n/**\n * @public\n * @function sanitizePath\n * @param    {Object}   options an options object\n * @returns  {Function}\n */\nfunction sanitizePath(options) {\n    options = options || {};\n\n    function _sanitizePath(req, res, next) {\n        req.url = strip(req.url);\n        next();\n    }\n\n    return (_sanitizePath);\n}\n\n\n///--- Exports\n\nmodule.exports = sanitizePath;\n\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/static.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar escapeRE = require('escape-regexp-component');\n\nvar assert = require('assert-plus');\nvar mime = require('mime');\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar MethodNotAllowedError = errors.MethodNotAllowedError;\nvar NotAuthorizedError = errors.NotAuthorizedError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\n\n\n///--- Functions\n\n/**\n * serves static files.\n * @public\n * @function serveStatic\n * @param    {Object} opts an options object\n * @throws   {MethodNotAllowedError |\n *            NotAuthorizedError |\n *            ResourceNotFoundError}\n * @returns  {Function}\n */\nfunction serveStatic(opts) {\n    opts = opts || {};\n    assert.object(opts, 'options');\n    assert.string(opts.directory, 'options.directory');\n    assert.optionalNumber(opts.maxAge, 'options.maxAge');\n    assert.optionalObject(opts.match, 'options.match');\n    assert.optionalString(opts.charSet, 'options.charSet');\n    assert.optionalString(opts.file, 'options.file');\n\n    var p = path.normalize(opts.directory).replace(/\\\\/g, '/');\n    var re = new RegExp('^' + escapeRE(p) + '/?.*');\n\n    function serveFileFromStats(file, err, stats, isGzip, req, res, next) {\n        if (err) {\n            next(new ResourceNotFoundError(err,\n                req.path()));\n            return;\n        } else if (!stats.isFile()) {\n            next(new ResourceNotFoundError('%s does not exist', req.path()));\n            return;\n        }\n\n        if (res.handledGzip && isGzip) {\n            res.handledGzip();\n        }\n\n        var fstream = fs.createReadStream(file + (isGzip ? '.gz' : ''));\n        var maxAge = opts.maxAge === undefined ? 3600 : opts.maxAge;\n        fstream.once('open', function (fd) {\n            res.cache({maxAge: maxAge});\n            res.set('Content-Length', stats.size);\n            res.set('Content-Type', mime.lookup(file));\n            res.set('Last-Modified', stats.mtime);\n\n            if (opts.charSet) {\n                var type = res.getHeader('Content-Type') +\n                    '; charset=' + opts.charSet;\n                res.setHeader('Content-Type', type);\n            }\n\n            if (opts.etag) {\n                res.set('ETag', opts.etag(stats, opts));\n            }\n            res.writeHead(200);\n            fstream.pipe(res);\n            fstream.once('end', function () {\n                next(false);\n            });\n        });\n    }\n\n    function serveNormal(file, req, res, next) {\n        fs.stat(file, function (err, stats) {\n            if (!err && stats.isDirectory() && opts.default) {\n                // Serve an index.html page or similar\n                file = path.join(file, opts.default);\n                fs.stat(file, function (dirErr, dirStats) {\n                    serveFileFromStats(file,\n                        dirErr,\n                        dirStats,\n                        false,\n                        req,\n                        res,\n                        next);\n                });\n            } else {\n                serveFileFromStats(file,\n                    err,\n                    stats,\n                    false,\n                    req,\n                    res,\n                    next);\n            }\n        });\n    }\n\n    function serve(req, res, next) {\n        var file;\n\n        if (opts.file) {\n            //serves a direct file\n            file = path.join(opts.directory,\n                decodeURIComponent(opts.file));\n        } else {\n            file = path.join(opts.directory,\n                decodeURIComponent(req.path()));\n        }\n\n        if (req.method !== 'GET' && req.method !== 'HEAD') {\n            next(new MethodNotAllowedError(req.method));\n            return;\n        }\n\n        if (!re.test(file.replace(/\\\\/g, '/'))) {\n            next(new NotAuthorizedError(req.path()));\n            return;\n        }\n\n        if (opts.match && !opts.match.test(file)) {\n            next(new NotAuthorizedError(req.path()));\n            return;\n        }\n\n        if (opts.gzip && req.acceptsEncoding('gzip')) {\n            fs.stat(file + '.gz', function (err, stats) {\n                if (!err) {\n                    res.setHeader('Content-Encoding', 'gzip');\n                    serveFileFromStats(file,\n                        err,\n                        stats,\n                        true,\n                        req,\n                        res,\n                        next);\n                } else {\n                    serveNormal(file, req, res, next);\n                }\n            });\n        } else {\n            serveNormal(file, req, res, next);\n        }\n\n    }\n\n    return (serve);\n}\n\nmodule.exports = serveStatic;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/throttle.js":"// Copyright 2012 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n'use strict';\n\nvar sprintf = require('util').format;\n\nvar assert = require('assert-plus');\nvar LRU = require('lru-cache');\n\nvar errors = require('../errors');\n\n\n///--- Globals\n\nvar TooManyRequestsError = errors.TooManyRequestsError;\n\nvar MESSAGE = 'You have exceeded your request rate of %s r/s.';\n\n\n///--- Helpers\n\nfunction xor() {\n    var x = false;\n\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] && !x) {\n            x = true;\n        } else if (arguments[i] && x) {\n            return (false);\n        }\n    }\n    return (x);\n}\n\n\n///--- Internal Class (TokenBucket)\n\n/**\n * An implementation of the Token Bucket algorithm.\n *\n * Basically, in network throttling, there are two \"mainstream\"\n * algorithms for throttling requests, Token Bucket and Leaky Bucket.\n * For restify, I went with Token Bucket.  For a good description of the\n * algorithm, see: http://en.wikipedia.org/wiki/Token_bucket\n *\n * In the options object, you pass in the total tokens and the fill rate.\n * Practically speaking, this means \"allow `fill rate` requests/second,\n * with bursts up to `total tokens`\".  Note that the bucket is initialized\n * to full.\n *\n * Also, in googling, I came across a concise python implementation, so this\n * is just a port of that. Thanks http://code.activestate.com/recipes/511490 !\n *\n * @private\n * @class\n * @param {Object} options contains the parameters:\n *                   - {Number} capacity the maximum burst.\n *                   - {Number} fillRate the rate to refill tokens.\n */\nfunction TokenBucket(options) {\n    assert.object(options, 'options');\n    assert.number(options.capacity, 'options.capacity');\n    assert.number(options.fillRate, 'options.fillRate');\n\n    this.tokens = this.capacity = options.capacity;\n    this.fillRate = options.fillRate;\n    this.time = Date.now();\n}\n\n\n/**\n * Consume N tokens from the bucket.\n *\n * If there is not capacity, the tokens are not pulled from the bucket.\n *\n * @private\n * @function consume\n * @param    {Number}  tokens the number of tokens to pull out.\n * @returns  {Boolean}        true if capacity, false otherwise.\n */\nTokenBucket.prototype.consume = function consume(tokens) {\n    if (tokens <= this._fill()) {\n        this.tokens -= tokens;\n        return (true);\n    }\n\n    return (false);\n};\n\n\n/**\n * Fills the bucket with more tokens.\n *\n * Rather than do some whacky setTimeout() deal, we just approximate refilling\n * the bucket by tracking elapsed time from the last time we touched the bucket.\n *\n * Simply, we set the bucket size to min(totalTokens,\n *                                       current + (fillRate * elapsed time)).\n *\n * @private\n * @function _fill\n * @returns  {Number} the current number of tokens in the bucket.\n */\nTokenBucket.prototype._fill = function _fill() {\n    var now = Date.now();\n\n    // reset account for clock drift (like DST)\n    if (now < this.time) {\n        this.time = now - 1000;\n    }\n\n    if (this.tokens < this.capacity) {\n        var delta = this.fillRate * ((now - this.time) / 1000);\n        this.tokens = Math.min(this.capacity, this.tokens + delta);\n    }\n    this.time = now;\n\n    return (this.tokens);\n};\n\n\n///--- Internal Class (TokenTable)\n/**\n * Just a wrapper over LRU that supports put/get to store token -> bucket\n * mappings.\n * @private\n * @class\n * @param {Object} options      an options object\n * @param {Number} options.size size of the LRU\n */\nfunction TokenTable(options) {\n    assert.object(options, 'options');\n\n    this.table = new LRU(options.size || 10000);\n}\n\n\n/**\n * puts a value in the token table\n * @private\n * @function put\n * @param {String}      key   a name\n * @param {TokenBucket} value a TokenBucket\n * @returns {undefined}\n */\nTokenTable.prototype.put = function put(key, value) {\n    this.table.set(key, value);\n};\n\n\n/**\n * puts a value in the token table\n * @private\n * @function get\n * @param {String} key a key\n * @returns {TokenBucket}\n */\nTokenTable.prototype.get = function get(key) {\n    return (this.table.get(key));\n};\n\n\n///--- Exported API\n\n/**\n * Creates an API rate limiter that can be plugged into the standard\n * restify request handling pipeline.\n *\n * This throttle gives you three options on which to throttle:\n * username, IP address and 'X-Forwarded-For'. IP/XFF is a /32 match,\n * so keep that in mind if using it.  Username takes the user specified\n * on req.username (which gets automagically set for supported Authorization\n * types; otherwise set it yourself with a filter that runs before this).\n *\n * In both cases, you can set a `burst` and a `rate` (in requests/seconds),\n * as an integer/float.  Those really translate to the `TokenBucket`\n * algorithm, so read up on that (or see the comments above...).\n *\n * In either case, the top level options burst/rate set a blanket throttling\n * rate, and then you can pass in an `overrides` object with rates for\n * specific users/IPs.  You should use overrides sparingly, as we make a new\n * TokenBucket to track each.\n *\n * On the `options` object ip and username are treated as an XOR.\n *\n * An example options object with overrides:\n *\n *  {\n *    burst: 10,  // Max 10 concurrent requests (if tokens)\n *    rate: 0.5,  // Steady state: 1 request / 2 seconds\n *    ip: true,   // throttle per IP\n *    overrides: {\n *      '192.168.1.1': {\n *        burst: 0,\n *        rate: 0    // unlimited\n *    }\n *  }\n *\n * @public\n * @function throttle\n * @throws   {TooManyRequestsError}\n * @param    {Object}    options required options with:\n *                   - {Number} burst (required).\n *                   - {Number} rate (required).\n *                   - {Boolean} ip (optional).\n *                   - {Boolean} username (optional).\n *                   - {Boolean} xff (optional).\n *                   - {Object} overrides (optional).\n *                   - {Object} tokensTable: a storage engine this plugin will\n *                              use to store throttling keys -> bucket mappings.\n *                              If you don't specify this, the default is to\n *                              use an in-memory O(1) LRU, with 10k distinct\n *                              keys.  Any implementation just needs to support\n *                              put/get.\n *                   - {Number} maxKeys: If using the default implementation,\n *                              you can specify how large you want the table to\n *                              be.  Default is 10000.\n * @returns  {Function}\n */\nfunction throttle(options) {\n    assert.object(options, 'options');\n    assert.number(options.burst, 'options.burst');\n    assert.number(options.rate, 'options.rate');\n\n    if (!xor(options.ip, options.xff, options.username)) {\n        throw new Error('(ip ^ username ^ xff)');\n    }\n\n    var table = options.tokensTable ||\n        new TokenTable({size: options.maxKeys});\n\n    function rateLimit(req, res, next) {\n        var attr;\n        var burst = options.burst;\n        var rate = options.rate;\n\n        if (options.ip) {\n            attr = req.connection.remoteAddress;\n        } else if (options.xff) {\n            attr = req.headers['x-forwarded-for'];\n        } else if (options.username) {\n            attr = req.username;\n        } else {\n            req.log.warn({config: options},\n                'Invalid throttle configuration');\n            return (next());\n        }\n\n        // Before bothering with overrides, see if this request\n        // even matches\n        if (!attr) {\n            return (next());\n        }\n\n        // Check the overrides\n        if (options.overrides &&\n            options.overrides[attr] &&\n            options.overrides[attr].burst !== undefined &&\n            options.overrides[attr].rate !== undefined) {\n\n            burst = options.overrides[attr].burst;\n            rate = options.overrides[attr].rate;\n        }\n\n        if (!rate || !burst) {\n            return (next());\n        }\n\n        var bucket = table.get(attr);\n\n        if (!bucket) {\n            bucket = new TokenBucket({\n                capacity: burst,\n                fillRate: rate\n            });\n            table.put(attr, bucket);\n        }\n\n        req.log.trace('Throttle(%s): num_tokens= %d',\n            attr, bucket.tokens);\n\n        if (!bucket.consume(1)) {\n            req.log.info({\n                address: req.connection.remoteAddress || '?',\n                method: req.method,\n                url: req.url,\n                user: req.username || '?'\n            }, 'Throttling');\n\n            var msg = sprintf(MESSAGE, rate);\n            return (next(new TooManyRequestsError(msg)));\n        }\n\n        return (next());\n    }\n\n    return (rateLimit);\n}\n\nmodule.exports = throttle;\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/pre/pause.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\n///--- Helpers\n\n/**\n * this pre handler fixes issues with node hanging when an asyncHandler is\n * used prior to bodyParser.\n * https://github.com/restify/node-restify/issues/287\n * https://github.com/restify/node-restify/issues/409\n * https://github.com/restify/node-restify/wiki/1.4-to-2.0-Migration-Tips\n * @public\n * @function pauseStream\n * @param    {Stream} stream the stream to pause\n * @returns  {undefined}\n */\nfunction pauseStream(stream) {\n    function _buffer(chunk) {\n        stream.__buffered.push(chunk);\n    }\n\n    function _catchEnd(chunk) {\n        stream.__rstfy_ended = true;\n    }\n\n    stream.__rstfy_ended = false;\n    stream.__rstfy_paused = true;\n    stream.__buffered = [];\n    stream.on('data', _buffer);\n    stream.once('end', _catchEnd);\n    stream.pause();\n\n    stream._resume = stream.resume;\n    stream.resume = function _rstfy_resume() {\n        if (!stream.__rstfy_paused) {\n            return;\n        }\n\n        stream.removeListener('data', _buffer);\n        stream.removeListener('end', _catchEnd);\n\n        stream.__buffered.forEach(stream.emit.bind(stream, 'data'));\n        stream.__buffered.length = 0;\n\n        stream._resume();\n        stream.resume = stream._resume;\n\n        if (stream.__rstfy_ended) {\n            stream.emit('end');\n        }\n    };\n}\n\n\n///--- Exports\n\nmodule.exports = function pause() {\n\n    function prePause(req, res, next) {\n        pauseStream(req);\n        next();\n    }\n\n    return (prePause);\n};\n","/home/travis/build/npmtest/node-npmtest-restify/restify/lib/plugins/pre/user_agent.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\n'use strict';\n\nvar assert = require('assert-plus');\n\n\n///--- API\n\n/**\n * This basically exists for curl.  curl on HEAD requests usually\n * just sits there and hangs, unless you explicitly set\n * Connection:close.  And in general, you probably want to set\n * Connection: close to curl anyway.\n *\n * Also, because curl spits out an annoying message to stderr about\n * remaining bytes if content-length is set, this plugin also drops\n * the content-length header (some user agents handle it and want it,\n * curl does not).\n *\n * To be slightly more generic, the options block takes a user\n * agent regexp, however.\n * @public\n * @function userAgentConnection\n * @param    {Object}   opts an options object\n * @returns  {Function}\n */\nfunction userAgentConnection(opts) {\n    assert.optionalObject(opts, 'options');\n    opts = opts || {};\n    assert.optionalObject(opts.userAgentRegExp, 'options.userAgentRegExp');\n\n    var re = opts.userAgentRegExp;\n\n    if (!re) {\n        re = /^curl.+/;\n    }\n\n    function handleUserAgent(req, res, next) {\n        var ua = req.headers['user-agent'];\n\n        if (ua && re.test(ua)) {\n            res.setHeader('Connection', 'close');\n        }\n\n        if (req.method === 'HEAD') {\n            res.once('header',\n                res.removeHeader.bind(res, 'content-length'));\n        }\n\n        next();\n    }\n\n    return (handleUserAgent);\n}\n\nmodule.exports = userAgentConnection;\n"}